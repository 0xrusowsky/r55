use std::process::Command;

const GENERATED_CODE_PATH: &str = "src/generated";

pub fn main() {
    println!("cargo:warning=Workspace root: {}", env!("CARGO_MANIFEST_DIR"));
    println!("cargo:warning=Current dir: {}", std::env::current_dir().unwrap().display());
    
    // Get the workspace root
    let workspace_root = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("Failed to find workspace root");
    
    println!("cargo:warning=Looking for linker script at: {}", workspace_root.join("r5-rust-rt.x").display());
    println!("cargo:warning=Linker script exists: {}", workspace_root.join("r5-rust-rt.x").exists());

    // Detect contracts (looking in examples directory like tests do)
    let contracts = vec![
        ("erc20", workspace_root.join("examples/erc20")),
        ("erc20x", workspace_root.join("examples/erc20x")),
        // Add other contracts here
    ];

    let mut bytecodes = Vec::new();
    
    for (name, path) in contracts {
        // Create a temporary .cargo/config.toml with absolute paths
        let cargo_config = format!(
            r#"[target.riscv64imac-unknown-none-elf]
rustflags = [
    "-C", "link-arg=-v",
    "-C", "link-arg=-T{}",
    "-C", "link-arg=-Tlink.x",
    "-C", "llvm-args=--inline-threshold=275"
]

[build]
target = "riscv64imac-unknown-none-elf"
"#,
            workspace_root.join("r5-rust-rt.x").display()
        );

        // Ensure .cargo directory exists
        let cargo_dir = path.join(".cargo");
        std::fs::create_dir_all(&cargo_dir).unwrap();
        std::fs::write(cargo_dir.join("config.toml"), cargo_config).unwrap();

        // Compile runtime first
        println!("Compiling runtime for {}", name);
        let runtime_bytecode = compile_runtime(path.to_str().unwrap());

        // Then compile deploy code
        println!("Compiling deploy for {}", name);
        let deploy_bytecode = compile_deploy(path.to_str().unwrap());

        bytecodes.push(ContractBytecode {
            name: name.to_string(),
            runtime_bytecode,
            deploy_bytecode,
        });
    }

    // Generate the bytecode module
    generate_bytecode_module(bytecodes);

    // Tell cargo to rerun if contract sources change
    println!("cargo:rerun-if-changed={}", workspace_root.join("examples").display());
    println!("cargo:rerun-if-changed={}", workspace_root.join("r5-rust-rt.x").display());
}

fn compile_runtime(path: &str) -> Vec<u8> {
    let status = Command::new("cargo")
        .arg("+nightly-2025-01-07")
        .arg("build")
        .arg("-r")
        .arg("--lib")
        .arg("-Z")
        .arg("build-std=core,alloc")
        .arg("--target")
        .arg("riscv64imac-unknown-none-elf")
        .arg("--bin")
        .arg("runtime")
        .arg("-v")
        .current_dir(path)
        .env("CARGO_TARGET_DIR", format!("{}/target", path)) // Explicit target dir
        .status()
        .expect("Failed to execute cargo command");
    
    if !status.success() {
        panic!("Failed to compile runtime for {}", path);
    }
    
    // Read the compiled binary
    let runtime_path = format!(
        "{}/target/riscv64imac-unknown-none-elf/release/runtime",
        path
    );
    
    std::fs::read(runtime_path).expect("Failed to read runtime binary")
}

fn compile_deploy(path: &str) -> Vec<u8> {
    let status = std::process::Command::new("cargo")
        .arg("+nightly-2025-01-07")
        .arg("build")
        .arg("-r")
        .arg("--lib")
        .arg("-Z")
        .arg("build-std=core,alloc")
        .arg("--target")
        .arg("riscv64imac-unknown-none-elf")
        .arg("--bin")
        .arg("deploy")
        .arg("--features")
        .arg("deploy")
        .current_dir(path)
        .status()
        .expect("Failed to execute cargo command");
    
    if !status.success() {
        panic!("Failed to compile deploy binary for {}", path);
    }
    
    // Read the compiled binary
    let deploy_path = format!(
        "{}/target/riscv64imac-unknown-none-elf/release/deploy",
        path
    );
    
    std::fs::read(deploy_path).expect("Failed to read deploy binary")
}

fn generate_bytecode_module(bytecodes: Vec<ContractBytecode>) {
    // Get the project root directory
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR")
        .expect("Failed to get manifest directory");
    
    // Create the generated code directory if it doesn't exist
    let generated_dir = std::path::Path::new(&manifest_dir).join(GENERATED_CODE_PATH);
    std::fs::create_dir_all(&generated_dir)
        .expect("Failed to create generated code directory");
    
    // Create the module content (same as before)
    let mut module = String::from("// Auto-generated bytecode module\n\n");
    
    for bytecode in &bytecodes {
        // Convert bytecode to Rust array literals
        let runtime_bytes = bytecode_to_rust_array(&bytecode.runtime_bytecode);
        let deploy_bytes = bytecode_to_rust_array(&bytecode.deploy_bytecode);
        
        // Add constants to the module
        module.push_str(&format!(
            "pub mod {} {{\n", 
            sanitize_name(&bytecode.name)
        ));
        
        module.push_str(&format!(
            "    pub const RUNTIME_BYTECODE: &[u8] = &[{}];\n", 
            runtime_bytes
        ));
        
        module.push_str(&format!(
            "    pub const DEPLOY_BYTECODE: &[u8] = &[{}];\n", 
            deploy_bytes
        ));
        
        module.push_str("}\n\n");
    }
    
    // Add a registry function
    module.push_str("pub fn get_contract_bytecode(name: &str) -> Option<(&'static [u8], &'static [u8])> {\n");
    module.push_str("    match name {\n");
    
    for bytecode in bytecodes {
        let name = sanitize_name(&bytecode.name);
        module.push_str(&format!(
            "        \"{}\" => Some(({0}::RUNTIME_BYTECODE, {0}::DEPLOY_BYTECODE)),\n",
            name
        ));
    }
    
    module.push_str("        _ => None,\n");
    module.push_str("    }\n");
    module.push_str("}\n");
    
    // Write the module to a file in the deterministic location
    let out_path = generated_dir.join("contract_bytecodes.rs");
    std::fs::write(out_path, module)
        .expect("Failed to write bytecode module");
    
    // Tell Cargo to rerun the build script if the generated file changes
    println!("cargo:rerun-if-changed={}/contract_bytecodes.rs", GENERATED_CODE_PATH);}

fn bytecode_to_rust_array(bytes: &[u8]) -> String {
    bytes.iter()
        .map(|b| format!("0x{:02x},", b))
        .collect::<Vec<_>>()
        .join(" ")
}

fn sanitize_name(name: &str) -> String {
    // Convert to a valid Rust identifier
    name.replace('-', "_").to_lowercase()
}
