use std::process::Command;

const GENERATED_CODE_PATH: &str = "src/generated";

struct ContractBytecode {
    name: String,
    runtime_bytecode: Vec<u8>,
    deploy_bytecode: Vec<u8>,
}

pub fn main() {
    println!("cargo:warning=Workspace root: {}", env!("CARGO_MANIFEST_DIR"));
    println!("cargo:warning=Current dir: {}", std::env::current_dir().unwrap().display());
    
    // Get the workspace root
    let workspace_root = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("Failed to find workspace root");
    
    println!("cargo:warning=Looking for linker script at: {}", workspace_root.join("r5-rust-rt.x").display());
    println!("cargo:warning=Linker script exists: {}", workspace_root.join("r5-rust-rt.x").exists());

    // Use relative paths like the test does
    let contracts = vec![
        ("erc20", "examples/erc20"),
        ("erc20x", "examples/erc20x"),
    ];

    let mut bytecodes = Vec::new();
    
    for (name, path) in contracts {
        // Compile runtime first
        println!("Compiling runtime for {}", name);
        let runtime_bytecode = compile_runtime(path.to_string().as_str());

        // Then compile deploy code
        println!("Compiling deploy for {}", name);
        let deploy_bytecode = compile_deploy(path.to_string().as_str());

        bytecodes.push(ContractBytecode {
            name: name.to_string(),
            runtime_bytecode,
            deploy_bytecode,
        });
    }

    // Generate the bytecode module
    generate_bytecode_module(bytecodes);

    // Tell cargo to rerun if contract sources change
    println!("cargo:rerun-if-changed={}", workspace_root.join("examples").display());
    println!("cargo:rerun-if-changed={}", workspace_root.join("r5-rust-rt.x").display());
}

fn compile_runtime(path: &str) -> Vec<u8> {
    // Get absolute paths
    let workspace_root = std::path::Path::new(env!("CARGO_MANIFEST_DIR"));
    let contract_path = workspace_root.parent().unwrap().join(path);
    
    println!("cargo:warning=Compiling from: {}", workspace_root.display());
    println!("cargo:warning=Contract path: {}", contract_path.display());

    let status = Command::new("cargo")
        .arg("+nightly-2025-01-07")
        .arg("build")
        .arg("-r")
        .arg("--lib")
        .arg("-Z")
        .arg("build-std=core,alloc")
        .arg("--target")
        .arg("riscv64imac-unknown-none-elf")
        .arg("--bin")
        .arg("runtime")
        .current_dir(workspace_root)
        .env("CARGO_TARGET_DIR", contract_path.join("target"))
        .status()
        .expect("Failed to execute cargo command");

    if !status.success() {
        panic!("Failed to compile runtime for {}", path);
    }

    std::fs::read(format!(
        "{}/target/riscv64imac-unknown-none-elf/release/runtime",
        contract_path.display()
    )).expect("Failed to read runtime binary")
}


fn compile_deploy(path: &str) -> Vec<u8> {
    let status = std::process::Command::new("cargo")
        .arg("+nightly-2025-01-07")
        .arg("build")
        .arg("-r")
        .arg("--lib")
        .arg("-Z")
        .arg("build-std=core,alloc")
        .arg("--target")
        .arg("riscv64imac-unknown-none-elf")
        .arg("--bin")
        .arg("deploy")
        .arg("--features")
        .arg("deploy")
        .current_dir(path)
        .status()
        .expect("Failed to execute cargo command");
    
    if !status.success() {
        panic!("Failed to compile deploy binary for {}", path);
    }
    
    // Read the compiled binary
    let deploy_path = format!(
        "{}/target/riscv64imac-unknown-none-elf/release/deploy",
        path
    );
    
    std::fs::read(deploy_path).expect("Failed to read deploy binary")
}

fn generate_bytecode_module(bytecodes: Vec<ContractBytecode>) {
    // Get the project root directory
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR")
        .expect("Failed to get manifest directory");
    
    // Create the generated code directory if it doesn't exist
    let generated_dir = std::path::Path::new(&manifest_dir).join(GENERATED_CODE_PATH);
    std::fs::create_dir_all(&generated_dir)
        .expect("Failed to create generated code directory");
    
    // Create the module content (same as before)
    let mut module = String::from("// Auto-generated bytecode module\n\n");
    
    for bytecode in &bytecodes {
        // Convert bytecode to Rust array literals
        let runtime_bytes = bytecode_to_rust_array(&bytecode.runtime_bytecode);
        let deploy_bytes = bytecode_to_rust_array(&bytecode.deploy_bytecode);
        
        // Add constants to the module
        module.push_str(&format!(
            "pub mod {} {{\n", 
            sanitize_name(&bytecode.name)
        ));
        
        module.push_str(&format!(
            "    pub const RUNTIME_BYTECODE: &[u8] = &[{}];\n", 
            runtime_bytes
        ));
        
        module.push_str(&format!(
            "    pub const DEPLOY_BYTECODE: &[u8] = &[{}];\n", 
            deploy_bytes
        ));
        
        module.push_str("}\n\n");
    }
    
    // Add a registry function
    module.push_str("pub fn get_contract_bytecode(name: &str) -> Option<(&'static [u8], &'static [u8])> {\n");
    module.push_str("    match name {\n");
    
    for bytecode in bytecodes {
        let name = sanitize_name(&bytecode.name);
        module.push_str(&format!(
            "        \"{}\" => Some(({0}::RUNTIME_BYTECODE, {0}::DEPLOY_BYTECODE)),\n",
            name
        ));
    }
    
    module.push_str("        _ => None,\n");
    module.push_str("    }\n");
    module.push_str("}\n");
    
    // Write the module to a file in the deterministic location
    let out_path = generated_dir.join("contract_bytecodes.rs");
    std::fs::write(out_path, module)
        .expect("Failed to write bytecode module");
    
    // Tell Cargo to rerun the build script if the generated file changes
    println!("cargo:rerun-if-changed={}/contract_bytecodes.rs", GENERATED_CODE_PATH);}

fn bytecode_to_rust_array(bytes: &[u8]) -> String {
    bytes.iter()
        .map(|b| format!("0x{:02x},", b))
        .collect::<Vec<_>>()
        .join(" ")
}

fn sanitize_name(name: &str) -> String {
    // Convert to a valid Rust identifier
    name.replace('-', "_").to_lowercase()
}
