Directory structure:
└── r55/
    ├── README.md
    ├── Cargo.toml
    ├── rust-toolchain.toml
    ├── contract-derive/
    │   ├── Cargo.toml
    │   └── src/
    │       ├── helpers.rs
    │       └── lib.rs
    ├── eth-riscv-interpreter/
    │   ├── Cargo.toml
    │   └── src/
    │       ├── error.rs
    │       └── lib.rs
    ├── eth-riscv-runtime/
    │   ├── Cargo.toml
    │   └── src/
    │       ├── alloc.rs
    │       ├── block.rs
    │       ├── call.rs
    │       ├── create.rs
    │       ├── error.rs
    │       ├── lib.rs
    │       ├── log.rs
    │       ├── tx.rs
    │       └── types/
    │           ├── mapping.rs
    │           ├── mod.rs
    │           └── slot.rs
    ├── eth-riscv-syscalls/
    │   ├── Cargo.toml
    │   └── src/
    │       ├── error.rs
    │       └── lib.rs
    ├── examples/
    │   ├── erc20/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   ├── erc20x/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   ├── erc721/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   └── evm-caller/
    │       ├── Cargo.toml
    │       └── src/
    │           └── lib.rs
    └── r55/
        ├── Cargo.toml
        ├── build.rs
        ├── src/
        │   ├── error.rs
        │   ├── exec.rs
        │   ├── gas.rs
        │   ├── lib.rs
        │   ├── test_utils.rs
        │   └── generated/
        │       └── contract_bytecodes.rs
        └── tests/
            ├── e2e.rs
            ├── erc20.rs
            ├── erc721.rs
            └── evm-contract-call.rs

================================================
File: README.md
================================================
# R55

R55 is an experimental Ethereum Execution Environment that seamlessly
integrates RISCV smart contracts alongside traditional EVM smart contracts.
This dual support operates over the same Ethereum state, and communication
happens via ABI-encoded calls.

On the high level, R55 enables the use of pure Rust smart contracts, opening
the door for a vast Rust developer community to engage in Ethereum development
with minimal barriers to entry, and increasing language and compiler diversity.

On the low level, RISCV code allows for optimization opportunities distinct
from the EVM, including the use of off-the-shelf ASICs. This potential for
performance gains can be particularly advantageous in specialized domains.

# Off-the-shelf tooling

R55 relies on standard tooling that programmers are used to, such as Rust,
Cargo and LLVM. This directly enables tooling such as linters, static
analyzers, testing, fuzzing, and formal verification tools to be applied to
these smart contracts without extra development and research.

# Pure & Clean Rust Smart Contracts

Differently from other platforms that offer Rust smart contracts, R55 lets the
user code in [no\_std] Rust without weird edges. The code below implements a
basic ERC20 token with infinite minting for testing.
Because the `struct` and `impl` are just Rust code, the user can write normal
tests and run them natively (as long as they don't need Ethereum host
functions).  Note that [alloy-rs](https://github.com/alloy-rs/) types work
out-of-the-box.

```rust
#![no_std]
#![no_main]

use core::default::Default;

use contract_derive::contract;
use eth_riscv_runtime::types::Mapping;

use alloy_core::primitives::Address;

#[derive(Default)]
pub struct ERC20 {
    balance: Mapping<Address, u64>,
}

#[contract]
impl ERC20 {
    pub fn balance_of(&self, owner: Address) -> u64 {
        self.balance.read(owner)
    }

    pub fn transfer(&self, from: Address, to: Address, value: u64) {
        let from_balance = self.balance.read(from);
        let to_balance = self.balance.read(to);

        if from == to || from_balance < value {
            revert();
        }

        self.balance.write(from, from_balance - value);
        self.balance.write(to, to_balance + value);
    }

    pub fn mint(&self, to: Address, value: u64) {
        let to_balance = self.balance.read(to);
        self.balance.write(to, to_balance + value);
    }
}
```

The macro `#[contract]` above is the only special treatment the user needs to
apply to their code. Specifically, it is responsible for the init code
(deployer), and for creating the function dispatcher based on the given
methods.
Note that Rust `pub` methods are exposed as public functions in the deployed
contract, similarly to Solidity's `public` functions.

# Client Integration

R55 is a fork of [revm](https://github.com/bluealloy/revm) without any API
changes.  Therefore it can be used seamlessly in Anvil/Reth to deploy a
testnet/network with support to RISCV smart contracts.
Nothing has to be changed in how transactions are handled or created.

# Relevant Links

- [revm-R55](https://github.com/r0qs/revm)
- [rvemu-R55](https://github.com/r55-eth/rvemu)
- [R55 Ethereum Runtime](https://github.com/r55-eth/r55/tree/main/eth-riscv-runtime)
- [R55 Compiler](https://github.com/r55-eth/r55/tree/main/r55)

# Prerequisites

## macOS

```shell
brew tap riscv-software-src/riscv
brew install riscv-gnu-toolchain gettext
```

# Test

The [R55](https://github.com/r55-eth/r55/tree/main/r55) crate has an [e2e test](https://github.com/r55-eth/r55/tree/main/r55/tests/e2e.rs)
that puts everything together in an end-to-end PoC, compiling the
[erc20](https://github.com/r55-eth/r55/tree/main/erc20) contract, deploying
it to an internal instance of [revm-r55](https://github.com/r0qs/revm), and
running two transactions on it, first a `mint` then a `balance_of` check.

You'll need to install Rust's RISCV toolchain:

```console
$ rustup install nightly-2024-02-01-x86_64-unknown-linux-gnu
```

Now run:

```console
$ cargo test --package r55 --test e2e -- erc20 --exact --show-output
...
Compiling deploy: erc20
Cargo command completed successfully
Deployed at addr: 0x522b3294e6d06aa25ad0f1b8891242e335d3b459
Tx result: 0x
Tx result: 0x000000000000000000000000000000000000000000000000000000000000002a
```

First R55 compiles the runtime RISCV-ELF binary that will be deployed. This is
needed to also compile the initcode RISCV-ELF binary that runs the constructor
and creates the contract.
The `mint` function has no return values, seen in `Tx result: 0x`. We minted 42
tokens to our test account in the first transaction, and we can see in the
second transaction that indeed the balance is 42 (0x2a).

# Architecture

The compiler uses `rustc`, `llvm`,
[eth-riscv-syscalls](https://github.com/r55-eth/r55/tree/main/eth-riscv-syscalls),
[eth-riscv-runtime](https://github.com/r55-eth/r55/tree/main/eth-riscv-runtime)
and [riscv-rt](https://github.com/rust-embedded/riscv/tree/master/riscv-rt) to
compile and link ELF binaries with low-level syscalls to be executed by
[rvemu-r55](https://github.com/r55-eth/rvemu):

```mermaid
graph TD;
    RustContract[Rust contract] --> CompiledContract[compiled contract]
    rustc --> CompiledContract
    llvm --> CompiledContract
    EthRiscVSyscalls[eth-riscv-syscalls] --> CompiledContract
    EthRiscVRuntime1[eth-riscv-runtime] --> CompiledContract
    CompiledContract --> LinkedRuntimeBytecode[linked runtime bytecode]
    EthRiscVRuntime2[eth-riscv-runtime] --> LinkedRuntimeBytecode
    riscv_rt[riscv-rt] --> LinkedRuntimeBytecode
    LinkedRuntimeBytecode --> LinkedInitBytecode[linked init bytecode]
    EthRiscVRuntime3[eth-riscv-runtime] --> LinkedInitBytecode
```

The execution environment depends on [revm](https://github.com/bluealloy/revm),
and relies on the [rvemu-r55](https://github.com/r55-eth/rvemu) RISCV
interpreter and
[eth-riscv-runtime](https://github.com/r55-eth/r55/tree/main/eth-riscv-runtime).

```mermaid
graph TD;
    revm --> revm-r55
    rvemu-r55 --> revm-r55
    eth-riscv-runtime --> revm-r55
```


================================================
File: Cargo.toml
================================================
[workspace]

resolver = "2"

members = ["eth-riscv-interpreter", "eth-riscv-syscalls", "r55"]
default-members = ["eth-riscv-interpreter", "eth-riscv-syscalls", "r55"]

exclude = [
    "contract-derive",
    "examples/*",
    "eth-riscv-runtime",
]

[workspace.package]
version = "0.1.0"
edition = "2021"
license = "Apache 2.0"
repository = "https://github.com/leonardoalt/r5"

[workspace.dependencies]
eth-riscv-interpreter = { path = "eth-riscv-interpreter" }
eth-riscv-syscalls = { path = "eth-riscv-syscalls" }

eyre = "0.6.12"
thiserror = "2.0.3"

tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }


================================================
File: rust-toolchain.toml
================================================
[toolchain]
channel= "1.84"


================================================
File: contract-derive/Cargo.toml
================================================
[package]
name = "contract-derive"
version = "0.1.0"
edition = "2021"

[dependencies]
proc-macro2 = "1.0"
quote = "1.0"
syn = { version = "1.0", features = ["full"] }
alloy-core = { version = "0.8.20", default-features = false }
alloy-sol-types = { version = "0.8.20", default-features = false }
alloy-dyn-abi = { version = "0.8.20", default-features = false }

[lib]
proc-macro = true


================================================
File: contract-derive/src/helpers.rs
================================================
use std::error::Error;

use alloy_core::primitives::keccak256;
use alloy_dyn_abi::DynSolType;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::{
    parse::{Parse, ParseStream},
    FnArg, Ident, ImplItemMethod, LitStr, PathArguments, ReturnType, TraitItemMethod, Type,
};

// Unified method info from `ImplItemMethod` and `TraitItemMethod`
#[derive(Clone)]
pub struct MethodInfo<'a> {
    name: &'a Ident,
    args: Vec<syn::FnArg>,
    return_type: &'a ReturnType,
}

impl<'a> From<&'a ImplItemMethod> for MethodInfo<'a> {
    fn from(method: &'a ImplItemMethod) -> Self {
        Self {
            name: &method.sig.ident,
            args: method.sig.inputs.iter().cloned().collect(),
            return_type: &method.sig.output,
        }
    }
}

impl<'a> From<&'a TraitItemMethod> for MethodInfo<'a> {
    fn from(method: &'a TraitItemMethod) -> Self {
        Self {
            name: &method.sig.ident,
            args: method.sig.inputs.iter().cloned().collect(),
            return_type: &method.sig.output,
        }
    }
}

impl<'a> MethodInfo<'a> {
    pub fn is_mutable(&self) -> bool {
        match self.args.first() {
            Some(FnArg::Receiver(receiver)) => receiver.mutability.is_some(),
            Some(FnArg::Typed(_)) => panic!("First argument must be self"),
            None => panic!("Expected `self` as the first arg"),
        }
    }

    pub fn returns_self(&self, self_name: &Ident) -> bool {
        match self.return_type {
            ReturnType::Type(_, ty) => match &**ty {
                Type::Path(path) => {
                    if path.path.segments.len() != 0 {
                        let segment = &path.path.segments[0];
                        segment.ident == "Self" || segment.ident == self_name.to_string().as_str()
                    } else {
                        false
                    }
                }
                _ => false,
            },
            ReturnType::Default => false,
        }
    }
}

// Helper function to get the parameter names + types of a method
fn get_arg_props<'a>(
    skip_first_arg: bool,
    method: &'a MethodInfo<'a>,
) -> (Vec<Ident>, Vec<&'a syn::Type>) {
    method
        .args
        .iter()
        .skip(if skip_first_arg { 1 } else { 0 })
        .enumerate()
        .map(|(i, arg)| {
            if let FnArg::Typed(pat_type) = arg {
                (format_ident!("arg{}", i), &*pat_type.ty)
            } else {
                panic!("Expected typed arguments");
            }
        })
        .unzip()
}

pub fn get_arg_props_skip_first<'a>(
    method: &'a MethodInfo<'a>,
) -> (Vec<Ident>, Vec<&'a syn::Type>) {
    get_arg_props(true, method)
}

pub fn get_arg_props_all<'a>(method: &'a MethodInfo<'a>) -> (Vec<Ident>, Vec<&'a syn::Type>) {
    get_arg_props(false, method)
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum InterfaceNamingStyle {
    CamelCase,
}

pub struct InterfaceArgs {
    pub rename: Option<InterfaceNamingStyle>,
}

impl Parse for InterfaceArgs {
    fn parse(input: ParseStream) -> Result<Self, syn::Error> {
        let rename_style = if !input.is_empty() {
            let value = if input.peek(LitStr) {
                input.parse::<LitStr>()?.value()
            } else {
                input.parse::<Ident>()?.to_string()
            };

            match value.as_str() {
                "camelCase" => Some(InterfaceNamingStyle::CamelCase),
                invalid => {
                    return Err(syn::Error::new(
                        input.span(),
                        format!(
                            "unsupported style: {}. Only 'camelCase' is supported",
                            invalid
                        ),
                    ))
                }
            }
        } else {
            None
        };

        Ok(InterfaceArgs {
            rename: rename_style,
        })
    }
}

// Helper function to generate interface impl from user-defined methods
pub fn generate_interface<T>(
    methods: &[&T],
    interface_name: &Ident,
    interface_style: Option<InterfaceNamingStyle>,
) -> quote::__private::TokenStream
where
    for<'a> MethodInfo<'a>: From<&'a T>,
{
    let methods: Vec<MethodInfo> = methods.iter().map(|&m| MethodInfo::from(m)).collect();
    let (mut_methods, immut_methods): (Vec<MethodInfo>, Vec<MethodInfo>) =
        methods.into_iter().partition(|m| m.is_mutable());

    // Generate implementations
    let mut_method_impls = mut_methods
        .iter()
        .map(|method| generate_method_impl(method, interface_style, true));
    let immut_method_impls = immut_methods
        .iter()
        .map(|method| generate_method_impl(method, interface_style, false));

    quote! {
        use core::marker::PhantomData;
        pub struct #interface_name<C: CallCtx> {
            pub address: Address,
            _ctx: PhantomData<C>
        }

        impl InitInterface for #interface_name<ReadOnly> {
            fn new(address: Address) -> InterfaceBuilder<Self> {
                InterfaceBuilder {
                    address,
                    _phantom: PhantomData
                }
            }
        }

        // Implement conversion between interface types
        impl<C: CallCtx> IntoInterface<#interface_name<C>> for #interface_name<ReadOnly> {
            fn into_interface(self) -> #interface_name<C> {
                #interface_name {
                    address: self.address,
                    _ctx: PhantomData
                }
            }
        }

        impl<C: CallCtx> FromBuilder for #interface_name<C> {
            type Context = C;

            fn from_builder(builder: InterfaceBuilder<Self>) -> Self {
                Self {
                    address: builder.address,
                    _ctx: PhantomData
                }
            }
        }

        impl<C: StaticCtx> #interface_name<C> {
            #(#immut_method_impls)*
        }

        impl<C: MutableCtx> #interface_name<C> {
            #(#mut_method_impls)*
        }
    }
}

fn generate_method_impl(
    method: &MethodInfo,
    interface_style: Option<InterfaceNamingStyle>,
    is_mutable: bool,
) -> TokenStream {
    let name = method.name;
    let return_type = method.return_type;
    let method_selector = u32::from_be_bytes(
        generate_fn_selector(method, interface_style).expect("Unable to generate fn selector"),
    );

    let (arg_names, arg_types) = get_arg_props_skip_first(method);

    let calldata = if arg_names.is_empty() {
        quote! {
            let mut complete_calldata = Vec::with_capacity(4);
            complete_calldata.extend_from_slice(&[
                #method_selector.to_be_bytes()[0],
                #method_selector.to_be_bytes()[1],
                #method_selector.to_be_bytes()[2],
                #method_selector.to_be_bytes()[3],
            ]);
        }
    } else {
        quote! {
            let mut args_calldata = (#(#arg_names),*).abi_encode();
            let mut complete_calldata = Vec::with_capacity(4 + args_calldata.len());
            complete_calldata.extend_from_slice(&[
                #method_selector.to_be_bytes()[0],
                #method_selector.to_be_bytes()[1],
                #method_selector.to_be_bytes()[2],
                #method_selector.to_be_bytes()[3],
            ]);
            complete_calldata.append(&mut args_calldata);
        }
    };

    let (call_fn, self_param) = if is_mutable {
        (
            quote! { eth_riscv_runtime::call_contract },
            quote! { &mut self },
        )
    } else {
        (
            quote! { eth_riscv_runtime::staticcall_contract },
            quote! { &self},
        )
    };

    // Generate different implementations based on return type
    match extract_wrapper_types(&method.return_type) {
        // If `Result<T, E>` handle each individual type
        WrapperType::Result(ok_type, err_type) => quote! {
            pub fn #name(#self_param, #(#arg_names: #arg_types),*) -> Result<#ok_type, #err_type>  {
                use alloy_sol_types::SolValue;
                use alloc::vec::Vec;

                #calldata

                let result = #call_fn(
                    self.address,
                    0_u64,
                    &complete_calldata,
                    None
                );

                match <#ok_type>::abi_decode(&result, true) {
                    Ok(decoded) => Ok(decoded),
                    Err(_) => Err(<#err_type>::abi_decode(&result, true))
                }
            }
        },
        // If `Option<T>` unwrap the type to decode, and wrap it back
        WrapperType::Option(return_ty) => {
            quote! {
                pub fn #name(#self_param, #(#arg_names: #arg_types),*) -> Option<#return_ty> {
                    use alloy_sol_types::SolValue;
                    use alloc::vec::Vec;

                    #calldata

                    let result = #call_fn(
                        self.address,
                        0_u64,
                        &complete_calldata,
                        None
                    );

                    match <#return_ty>::abi_decode(&result, true) {
                        Ok(decoded) => Some(decoded),
                        Err(_) => None
                    }
                }
            }
        }
        // Otherwise, simply decode the value + wrap it in an `Option` to force error-handling
        WrapperType::None => {
            let return_ty = match return_type {
                ReturnType::Default => quote! { () },
                ReturnType::Type(_, ty) => quote! { #ty },
            };
            quote! {
                pub fn #name(#self_param, #(#arg_names: #arg_types),*) -> Option<#return_ty> {
                    use alloy_sol_types::SolValue;
                    use alloc::vec::Vec;

                    #calldata

                    let result = #call_fn(
                        self.address,
                        0_u64,
                        &complete_calldata,
                        None
                    );

                    match <#return_ty>::abi_decode(&result, true) {
                        Ok(decoded) => Some(decoded),
                        Err(_) => None
                    }
                }
            }
        }
    }
}

pub enum WrapperType {
    Result(TokenStream, TokenStream),
    Option(TokenStream),
    None,
}

// Helper function to extract Result or Option types if present
pub fn extract_wrapper_types(return_type: &ReturnType) -> WrapperType {
    let type_path = match return_type {
        ReturnType::Default => return WrapperType::None,
        ReturnType::Type(_, ty) => match ty.as_ref() {
            Type::Path(type_path) => type_path,
            _ => return WrapperType::None,
        },
    };

    let last_segment = match type_path.path.segments.last() {
        Some(segment) => segment,
        None => return WrapperType::None,
    };

    match last_segment.ident.to_string().as_str() {
        "Result" => {
            let PathArguments::AngleBracketed(args) = &last_segment.arguments else {
                return WrapperType::None;
            };

            let type_args: Vec<_> = args.args.iter().collect();
            if type_args.len() != 2 {
                return WrapperType::None;
            }

            // Convert the generic arguments to TokenStreams directly
            let ok_type = match &type_args[0] {
                syn::GenericArgument::Type(t) => quote!(#t),
                _ => return WrapperType::None,
            };

            let err_type = match &type_args[1] {
                syn::GenericArgument::Type(t) => quote!(#t),
                _ => return WrapperType::None,
            };

            WrapperType::Result(ok_type, err_type)
        }
        "Option" => {
            let PathArguments::AngleBracketed(args) = &last_segment.arguments else {
                return WrapperType::None;
            };

            let type_args: Vec<_> = args.args.iter().collect();
            if type_args.len() != 1 {
                return WrapperType::None;
            }

            // Convert the generic argument to TokenStream
            let inner_type = match &type_args[0] {
                syn::GenericArgument::Type(t) => quote!(#t),
                _ => return WrapperType::None,
            };

            WrapperType::Option(inner_type)
        }
        _ => WrapperType::None,
    }
}

// Helper function to generate fn selector
pub fn generate_fn_selector(
    method: &MethodInfo,
    style: Option<InterfaceNamingStyle>,
) -> Option<[u8; 4]> {
    let name = match style {
        None => method.name.to_string(),
        Some(style) => match style {
            InterfaceNamingStyle::CamelCase => to_camel_case(method.name.to_string()),
        },
    };

    let (_, arg_types) = get_arg_props_skip_first(method);
    let args = arg_types
        .iter()
        .map(|ty| rust_type_to_sol_type(ty))
        .collect::<Result<Vec<_>, _>>()
        .ok()?;
    let args_str = args
        .iter()
        .map(|ty| ty.sol_type_name().into_owned())
        .collect::<Vec<_>>()
        .join(",");

    let selector = format!("{}({})", name, args_str);
    let selector_bytes = keccak256(selector.as_bytes())[..4].try_into().ok()?;
    Some(selector_bytes)
}

// Helper function to generate fn selector for the constructor
pub fn generate_constructor_selector(
    method: &MethodInfo,
    style: Option<InterfaceNamingStyle>,
) -> Option<[u8; 4]> {
    let name = method.name.to_string();
    let (_, arg_types) = get_arg_props_all(method);
    let args = arg_types
        .iter()
        .map(|ty| rust_type_to_sol_type(ty))
        .collect::<Result<Vec<_>, _>>()
        .ok()?;
    let args_str = args
        .iter()
        .map(|ty| ty.sol_type_name().into_owned())
        .collect::<Vec<_>>()
        .join(",");

    let selector = format!("{}({})", name, args_str);
    let selector_bytes = keccak256(selector.as_bytes())[..4].try_into().ok()?;
    Some(selector_bytes)
}

// Helper function to convert rust types to their solidity equivalent
// TODO: make sure that the impl is robust, so far only tested with "simple types"
pub fn rust_type_to_sol_type(ty: &Type) -> Result<DynSolType, &'static str> {
    match ty {
        Type::Path(type_path) => {
            let path = &type_path.path;
            let segment = path.segments.last().ok_or("Empty type path")?;
            let ident = &segment.ident;
            let type_name = ident.to_string();

            match type_name.as_str() {
                // Fixed-size types
                "Address" => Ok(DynSolType::Address),
                "Function" => Ok(DynSolType::Function),
                "bool" | "Bool" => Ok(DynSolType::Bool),
                "String" | "str" => Ok(DynSolType::String),
                "Bytes" => Ok(DynSolType::Bytes),
                // Fixed-size bytes
                b if b.starts_with('B') => {
                    let size: usize = b
                        .trim_start_matches('B')
                        .parse()
                        .map_err(|_| "Invalid fixed bytes size")?;
                    if size > 0 && size <= 32 {
                        Ok(DynSolType::FixedBytes(size))
                    } else {
                        Err("Invalid fixed bytes size (between 1-32)")
                    }
                }
                // Fixed-size unsigned integers
                u if u.starts_with('U') => {
                    let size: usize = u
                        .trim_start_matches('U')
                        .parse()
                        .map_err(|_| "Invalid uint size")?;
                    if size > 0 && size <= 256 && size % 8 == 0 {
                        Ok(DynSolType::Uint(size))
                    } else {
                        Err("Invalid uint size (multiple of 8 + leq 256)")
                    }
                }
                // Fixed-size signed integers
                i if i.starts_with('I') => {
                    let size: usize = i
                        .trim_start_matches('I')
                        .parse()
                        .map_err(|_| "Invalid int size")?;
                    if size > 0 && size <= 256 && size % 8 == 0 {
                        Ok(DynSolType::Int(size))
                    } else {
                        Err("Invalid int size (must be multiple of 8, max 256)")
                    }
                }
                // Handle vecs
                _ => {
                    if let syn::PathArguments::AngleBracketed(args) = &segment.arguments {
                        match type_name.as_str() {
                            "Vec" => {
                                let inner = args.args.first().ok_or("Empty Vec type argument")?;
                                if let syn::GenericArgument::Type(inner_ty) = inner {
                                    let inner_sol_type = rust_type_to_sol_type(inner_ty)?;
                                    Ok(DynSolType::Array(Box::new(inner_sol_type)))
                                } else {
                                    Err("Invalid Vec type argument")
                                }
                            }
                            _ => Err("Unsupported generic type"),
                        }
                    } else {
                        Err("Unsupported type")
                    }
                }
            }
        }
        Type::Array(array) => {
            let inner_sol_type = rust_type_to_sol_type(&array.elem)?;
            if let syn::Expr::Lit(lit) = &array.len {
                if let syn::Lit::Int(size) = &lit.lit {
                    let size: usize = size
                        .base10_digits()
                        .parse()
                        .map_err(|_| "Invalid array size")?;
                    Ok(DynSolType::FixedArray(Box::new(inner_sol_type), size))
                } else {
                    Err("Invalid array size literal")
                }
            } else {
                Err("Invalid array size expression")
            }
        }
        Type::Tuple(tuple) => {
            let inner_types = tuple
                .elems
                .iter()
                .map(rust_type_to_sol_type)
                .collect::<Result<Vec<_>, _>>()?;
            Ok(DynSolType::Tuple(inner_types))
        }
        _ => Err("Unsupported type"),
    }
}

fn to_camel_case(s: String) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;

    // Iterate through characters, skipping non-alphabetic separators
    for (i, c) in s.chars().enumerate() {
        if c.is_alphanumeric() {
            if i == 0 {
                result.push(c.to_ascii_lowercase());
            } else if capitalize_next {
                result.push(c.to_ascii_uppercase());
                capitalize_next = false;
            } else {
                result.push(c);
            }
        } else {
            // Set flag to capitalize next char  with non-alphanumeric ones
            capitalize_next = true;
        }
    }

    result
}

// Helper function to generate the deployment code
pub fn generate_deployment_code(
    struct_name: &Ident,
    constructor: Option<&ImplItemMethod>,
) -> quote::__private::TokenStream {
    // Decode constructor args + trigger constructor logic
    let constructor_code = match constructor {
        Some(method) => {
            let method_info = MethodInfo::from(method);
            let (arg_names, arg_types) = get_arg_props_all(&method_info);
            quote! {
                impl #struct_name { #method }

                // Get encoded constructor args
                let calldata = eth_riscv_runtime::msg_data();

                let (#(#arg_names),*) = <(#(#arg_types),*)>::abi_decode(&calldata, true)
                    .expect("Failed to decode constructor args");
                #struct_name::new(#(#arg_names),*);
            }
        }
        None => quote! {
            #struct_name::default();
        },
    };

    quote! {
        use alloc::vec::Vec;
        use alloy_core::primitives::U32;

        #[no_mangle]
        pub extern "C" fn main() -> ! {
            #constructor_code

            // Return runtime code
            let runtime: &[u8] = include_bytes!("../target/riscv64imac-unknown-none-elf/release/runtime");
            let mut prepended_runtime = Vec::with_capacity(1 + runtime.len());
            prepended_runtime.push(0xff);
            prepended_runtime.extend_from_slice(runtime);

            let prepended_runtime_slice: &[u8] = &prepended_runtime;
            let result_ptr = prepended_runtime_slice.as_ptr() as u64;
            let result_len = prepended_runtime_slice.len() as u64;
            eth_riscv_runtime::return_riscv(result_ptr, result_len);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use syn::parse_quote;

    struct MockMethod {
        method: ImplItemMethod,
    }

    impl MockMethod {
        fn new(name: &str, args: Vec<&str>) -> Self {
            let name_ident = syn::Ident::new(name, proc_macro2::Span::call_site());
            let args_tokens = if args.is_empty() {
                quote!()
            } else {
                let args = args.iter().map(|arg| {
                    let parts: Vec<&str> = arg.split(": ").collect();
                    let arg_name = syn::Ident::new(parts[0], proc_macro2::Span::call_site());
                    let type_str = parts[1];
                    let type_tokens: proc_macro2::TokenStream = type_str.parse().unwrap();
                    quote!(#arg_name: #type_tokens)
                });
                quote!(, #(#args),*)
            };

            let method: ImplItemMethod = parse_quote! {
                fn #name_ident(&self #args_tokens) {}
            };
            Self { method }
        }

        fn info(&self) -> MethodInfo {
            MethodInfo::from(self)
        }
    }

    impl<'a> From<&'a MockMethod> for MethodInfo<'a> {
        fn from(test_method: &'a MockMethod) -> Self {
            MethodInfo::from(&test_method.method)
        }
    }

    pub fn get_selector_from_sig(sig: &str) -> [u8; 4] {
        keccak256(sig.as_bytes())[0..4]
            .try_into()
            .expect("Selector should have exactly 4 bytes")
    }

    #[test]
    fn test_rust_to_sol_basic_types() {
        let test_cases = vec![
            (parse_quote!(Address), DynSolType::Address),
            (parse_quote!(Function), DynSolType::Function),
            (parse_quote!(bool), DynSolType::Bool),
            (parse_quote!(Bool), DynSolType::Bool),
            (parse_quote!(String), DynSolType::String),
            (parse_quote!(str), DynSolType::String),
            (parse_quote!(Bytes), DynSolType::Bytes),
        ];

        for (rust_type, expected_sol_type) in test_cases {
            assert_eq!(
                rust_type_to_sol_type(&rust_type).unwrap(),
                expected_sol_type
            );
        }
    }

    #[test]
    fn test_rust_to_sol_fixed_bytes() {
        let test_cases = vec![
            (parse_quote!(B1), DynSolType::FixedBytes(1)),
            (parse_quote!(B16), DynSolType::FixedBytes(16)),
            (parse_quote!(B32), DynSolType::FixedBytes(32)),
        ];

        for (rust_type, expected_sol_type) in test_cases {
            assert_eq!(
                rust_type_to_sol_type(&rust_type).unwrap(),
                expected_sol_type
            );
        }

        // Invalid cases
        assert!(rust_type_to_sol_type(&parse_quote!(B0)).is_err());
        assert!(rust_type_to_sol_type(&parse_quote!(B33)).is_err());
    }

    #[test]
    fn test_rust_to_sol_integers() {
        let test_cases = vec![
            (parse_quote!(U8), DynSolType::Uint(8)),
            (parse_quote!(U256), DynSolType::Uint(256)),
            (parse_quote!(I8), DynSolType::Int(8)),
            (parse_quote!(I256), DynSolType::Int(256)),
        ];

        for (rust_type, expected_sol_type) in test_cases {
            assert_eq!(
                rust_type_to_sol_type(&rust_type).unwrap(),
                expected_sol_type
            );
        }

        // Invalid cases
        assert!(rust_type_to_sol_type(&parse_quote!(U0)).is_err());
        assert!(rust_type_to_sol_type(&parse_quote!(U257)).is_err());
        assert!(rust_type_to_sol_type(&parse_quote!(U7)).is_err()); // Not multiple of 8
        assert!(rust_type_to_sol_type(&parse_quote!(I0)).is_err());
        assert!(rust_type_to_sol_type(&parse_quote!(I257)).is_err());
        assert!(rust_type_to_sol_type(&parse_quote!(I7)).is_err()); // Not multiple of 8
    }

    #[test]
    fn test_rust_to_sol_arrays() {
        // Dynamic arrays (Vec)
        assert_eq!(
            rust_type_to_sol_type(&parse_quote!(Vec<U256>)).unwrap(),
            DynSolType::Array(Box::new(DynSolType::Uint(256)))
        );

        assert_eq!(
            rust_type_to_sol_type(&parse_quote!(Vec<Bool>)).unwrap(),
            DynSolType::Array(Box::new(DynSolType::Bool))
        );

        // Fixed-size arrays
        assert_eq!(
            rust_type_to_sol_type(&parse_quote!([U256; 5])).unwrap(),
            DynSolType::FixedArray(Box::new(DynSolType::Uint(256)), 5)
        );

        assert_eq!(
            rust_type_to_sol_type(&parse_quote!([Bool; 3])).unwrap(),
            DynSolType::FixedArray(Box::new(DynSolType::Bool), 3)
        );
    }

    #[test]
    fn test_rust_to_sol_tuples() {
        assert_eq!(
            rust_type_to_sol_type(&parse_quote!((U256, Bool))).unwrap(),
            DynSolType::Tuple(vec![DynSolType::Uint(256), DynSolType::Bool])
        );

        assert_eq!(
            rust_type_to_sol_type(&parse_quote!((Address, B32, I128))).unwrap(),
            DynSolType::Tuple(vec![
                DynSolType::Address,
                DynSolType::FixedBytes(32),
                DynSolType::Int(128)
            ])
        );
    }

    #[test]
    fn test_rust_to_sol_nested_types() {
        // Nested Vec
        assert_eq!(
            rust_type_to_sol_type(&parse_quote!(Vec<Vec<U256>>)).unwrap(),
            DynSolType::Array(Box::new(DynSolType::Array(Box::new(DynSolType::Uint(256)))))
        );

        // Nested fixed array
        assert_eq!(
            rust_type_to_sol_type(&parse_quote!([[U256; 2]; 3])).unwrap(),
            DynSolType::FixedArray(
                Box::new(DynSolType::FixedArray(Box::new(DynSolType::Uint(256)), 2)),
                3
            )
        );

        // Nested tuple
        assert_eq!(
            rust_type_to_sol_type(&parse_quote!((U256, (Bool, Address)))).unwrap(),
            DynSolType::Tuple(vec![
                DynSolType::Uint(256),
                DynSolType::Tuple(vec![DynSolType::Bool, DynSolType::Address])
            ])
        );
    }

    #[test]
    fn test_rust_to_sol_invalid_types() {
        // Invalid type names
        assert!(rust_type_to_sol_type(&parse_quote!(InvalidType)).is_err());

        // Invalid generic types
        assert!(rust_type_to_sol_type(&parse_quote!(Option<U256>)).is_err());
        assert!(rust_type_to_sol_type(&parse_quote!(Result<U256>)).is_err());
    }

    #[test]
    fn test_fn_selector() {
        // No arguments
        let method = MockMethod::new("balance", vec![]);
        assert_eq!(
            generate_fn_selector(&method.info(), None).unwrap(),
            get_selector_from_sig("balance()"),
        );

        // Single argument
        let method = MockMethod::new("transfer", vec!["to: Address"]);
        assert_eq!(
            generate_fn_selector(&method.info(), None).unwrap(),
            get_selector_from_sig("transfer(address)"),
        );

        // Multiple arguments
        let method = MockMethod::new(
            "transfer_from",
            vec!["from: Address", "to: Address", "amount: U256"],
        );
        assert_eq!(
            generate_fn_selector(&method.info(), None).unwrap(),
            get_selector_from_sig("transfer_from(address,address,uint256)")
        );

        // Dynamic arrays
        let method = MockMethod::new("batch_transfer", vec!["recipients: Vec<Address>"]);
        assert_eq!(
            generate_fn_selector(&method.info(), None).unwrap(),
            get_selector_from_sig("batch_transfer(address[])")
        );

        // Tuples
        let method = MockMethod::new(
            "complex_transfer",
            vec!["data: (Address, U256)", "check: (Vec<Address>, Vec<Bool>)"],
        );
        assert_eq!(
            generate_fn_selector(&method.info(), None).unwrap(),
            get_selector_from_sig("complex_transfer((address,uint256),(address[],bool[]))")
        );

        // Fixed arrays
        let method = MockMethod::new("multi_transfer", vec!["amounts: [U256; 3]"]);
        assert_eq!(
            generate_fn_selector(&method.info(), None).unwrap(),
            get_selector_from_sig("multi_transfer(uint256[3])")
        );
    }

    #[test]
    fn test_fn_selector_rename_camel_case() {
        let method = MockMethod::new("get_balance", vec![]);
        assert_eq!(
            generate_fn_selector(&method.info(), Some(InterfaceNamingStyle::CamelCase)).unwrap(),
            get_selector_from_sig("getBalance()")
        );

        let method = MockMethod::new("transfer_from_account", vec!["to: Address"]);
        assert_eq!(
            generate_fn_selector(&method.info(), Some(InterfaceNamingStyle::CamelCase)).unwrap(),
            get_selector_from_sig("transferFromAccount(address)")
        );
    }

    #[test]
    fn test_fn_selector_erc20() {
        let cases = vec![
            ("totalSupply", vec![], "totalSupply()"),
            ("balanceOf", vec!["account: Address"], "balanceOf(address)"),
            (
                "transfer",
                vec!["recipient: Address", "amount: U256"],
                "transfer(address,uint256)",
            ),
            (
                "allowance",
                vec!["owner: Address", "spender: Address"],
                "allowance(address,address)",
            ),
            (
                "approve",
                vec!["spender: Address", "amount: U256"],
                "approve(address,uint256)",
            ),
            (
                "transferFrom",
                vec!["sender: Address", "recipient: Address", "amount: U256"],
                "transferFrom(address,address,uint256)",
            ),
        ];

        for (name, args, signature) in cases {
            let method = MockMethod::new(name, args);
            assert_eq!(
                generate_fn_selector(&method.info(), None).unwrap(),
                get_selector_from_sig(signature),
                "Selector mismatch for {}",
                signature
            );
        }
    }

    #[test]
    fn test_fn_selector_erc721() {
        let cases = vec![
            (
                "safeTransferFrom",
                vec![
                    "from: Address",
                    "to: Address",
                    "tokenId: U256",
                    "data: Bytes",
                ],
                "safeTransferFrom(address,address,uint256,bytes)",
            ),
            ("name", vec![], "name()"),
            ("symbol", vec![], "symbol()"),
            ("tokenURI", vec!["tokenId: U256"], "tokenURI(uint256)"),
            (
                "approve",
                vec!["to: Address", "tokenId: U256"],
                "approve(address,uint256)",
            ),
            (
                "setApprovalForAll",
                vec!["operator: Address", "approved: bool"],
                "setApprovalForAll(address,bool)",
            ),
        ];

        for (name, args, signature) in cases {
            let method = MockMethod::new(name, args);
            assert_eq!(
                generate_fn_selector(&method.info(), None).unwrap(),
                get_selector_from_sig(signature),
                "Selector mismatch for {}",
                signature
            );
        }
    }
}


================================================
File: contract-derive/src/lib.rs
================================================
extern crate proc_macro;
use alloy_core::primitives::U256;
use alloy_sol_types::SolValue;
use proc_macro::TokenStream;
use quote::{format_ident, quote};
use syn::{
    parse_macro_input, Data, DeriveInput, Fields, ImplItem, ImplItemMethod,
    ItemImpl, ItemTrait, ReturnType, TraitItem,
};

mod helpers;
use crate::helpers::{InterfaceArgs, MethodInfo};

#[proc_macro_derive(Error)]
pub fn error_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;

    let variants = if let Data::Enum(data) = &input.data {
        &data.variants
    } else {
        panic!("`Error` must be an enum");
    };

    // Generate error encoding for each variant
    let encode_arms = variants.iter().map(|variant| {
        let variant_name = &variant.ident;

        let signature = match &variant.fields {
            Fields::Unit => {
                format!("{}::{}", name, variant_name)
            }
            Fields::Unnamed(fields) => {
                let type_names: Vec<_> = fields
                    .unnamed
                    .iter()
                    .map(|f| {
                        helpers::rust_type_to_sol_type(&f.ty)
                            .expect("Unknown type")
                            .sol_type_name()
                            .into_owned()
                    })
                    .collect();

                format!("{}::{}({})", name, variant_name, type_names.join(","))
            }
            Fields::Named(_) => panic!("Named fields are not supported"),
        };

        let pattern = match &variant.fields {
            Fields::Unit => quote! { #name::#variant_name },
            Fields::Unnamed(fields) => {
                let vars: Vec<_> = (0..fields.unnamed.len())
                    .map(|i| format_ident!("_{}", i))
                    .collect();
                quote! { #name::#variant_name(#(#vars),*) }
            }
            Fields::Named(_) => panic!("Named fields are not supported"),
        };

        // non-unit variants must encode the data
        let data = match &variant.fields {
            Fields::Unit => quote! {},
            Fields::Unnamed(fields) => {
                let vars = (0..fields.unnamed.len()).map(|i| format_ident!("_{}", i));
                quote! { #( res.extend_from_slice(&#vars.abi_encode()); )* }
            }
            Fields::Named(_) => panic!("Named fields are not supported"),
        };

        quote! {
            #pattern => {
                let mut res = Vec::new();
                let selector = keccak256(#signature.as_bytes())[..4].to_vec();
                res.extend_from_slice(&selector);
                #data
                res
            }
        }
    });

    // Generate error decoding for each variant
    let decode_arms = variants.iter().map(|variant| {
        let variant_name = &variant.ident;
        
        let signature = match &variant.fields {
            Fields::Unit => {
                format!("{}::{}", name, variant_name)
            },
            Fields::Unnamed(fields) => {
                let type_names: Vec<_> = fields.unnamed.iter()
                    .map(|f| helpers::rust_type_to_sol_type(&f.ty)
                        .expect("Unknown type")
                        .sol_type_name()
                        .into_owned()
                    ).collect();
                
                format!("{}::{}({})",
                    name,
                    variant_name,
                    type_names.join(",")
                )
            },
            Fields::Named(_) => panic!("Named fields are not supported"),
        };

        let selector_bytes = quote!{ &keccak256(#signature.as_bytes())[..4].to_vec() };

        match &variant.fields {
            Fields::Unit => quote! { selector if selector == #selector_bytes => #name::#variant_name },
            Fields::Unnamed(fields) => {
                let field_types: Vec<_> = fields.unnamed.iter().map(|f| &f.ty).collect();
                let indices: Vec<_> = (0..fields.unnamed.len()).collect();
                quote!{ selector if selector == #selector_bytes => {
                    let mut values = Vec::new();
                    #( values.push(<#field_types>::abi_decode(data.unwrap(), true).expect("Unable to decode")); )*
                    #name::#variant_name(#(values[#indices]),*)
                }} 
            },
            Fields::Named(_) => panic!("Named fields are not supported"),
        }
    });

    // Generate `Debug` implementation for each variant
    let debug_arms = variants.iter().map(|variant| {
        let variant_name = &variant.ident;

        match &variant.fields {
            Fields::Unit => quote! {
                #name::#variant_name => { f.write_str(stringify!(#variant_name)) }
            },
            Fields::Unnamed(fields) => {
                let vars: Vec<_> = (0..fields.unnamed.len())
                    .map(|i| format_ident!("_{}", i))
                    .collect();
                quote! {
                    #name::#variant_name(#(#vars),*) => {
                        f.debug_tuple(stringify!(#variant_name))
                            #(.field(#vars))*
                            .finish()
                    }
                }
            }
            Fields::Named(_) => panic!("Named fields are not supported"),
        }
    });

    let expanded = quote! {
        impl eth_riscv_runtime::error::Error for #name {
            fn abi_encode(&self) -> alloc::vec::Vec<u8> {
                use alloy_core::primitives::keccak256;
                use alloc::vec::Vec;

                match self { #(#encode_arms),* }
            }

            fn abi_decode(bytes: &[u8], validate: bool) -> Self {
                use alloy_core::primitives::keccak256;
                use alloy_sol_types::SolValue;
                use alloc::vec::Vec;

                if bytes.len() < 4 { panic!("Invalid error length") };
                let selector = &bytes[..4];
                let data = if bytes.len() > 4 { Some(&bytes[4..]) } else { None };

                match selector {
                    #(#decode_arms),*,
                    _ => panic!("Unknown error")
                }
            }
        }

        impl core::fmt::Debug for #name {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                match self { #(#debug_arms),* }
            }
        }
    };

    TokenStream::from(expanded)
}

#[proc_macro_derive(Event, attributes(indexed))]
pub fn event_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;

    let fields = if let Data::Struct(data) = &input.data {
        if let Fields::Named(fields) = &data.fields {
            &fields.named
        } else {
            panic!("Event must have named fields");
        }
    } else {
        panic!("Event must be a struct");
    };

    // Collect iterators into vectors
    let field_names: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let field_types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let indexed_fields: Vec<_> = fields
        .iter()
        .filter(|f| f.attrs.iter().any(|attr| attr.path.is_ident("indexed")))
        .map(|f| &f.ident)
        .collect();

    let expanded = quote! {
        impl #name {
            const NAME: &'static str = stringify!(#name);
            const INDEXED_FIELDS: &'static [&'static str] = &[
                #(stringify!(#indexed_fields)),*
            ];

            pub fn new(#(#field_names: #field_types),*) -> Self {
                Self {
                    #(#field_names),*
                }
            }
        }

        impl eth_riscv_runtime::log::Event for #name {
            fn encode_log(&self) -> (alloc::vec::Vec<u8>, alloc::vec::Vec<[u8; 32]>) {
                use alloy_sol_types::SolValue;
                use alloy_core::primitives::{keccak256, B256};
                use alloc::vec::Vec;

                let mut signature = Vec::new();
                signature.extend_from_slice(Self::NAME.as_bytes());
                signature.extend_from_slice(b"(");

                let mut first = true;
                let mut topics = alloc::vec![B256::default()];
                let mut data = Vec::new();

                #(
                    if !first { signature.extend_from_slice(b","); }
                    first = false;

                    signature.extend_from_slice(self.#field_names.sol_type_name().as_bytes());
                    let encoded = self.#field_names.abi_encode();

                    let field_name = stringify!(#field_names);
                    if Self::INDEXED_FIELDS.contains(&field_name) && topics.len() < 4 {
                        topics.push(B256::from_slice(&encoded));
                    } else {
                        data.extend_from_slice(&encoded);
                    }
                )*

                signature.extend_from_slice(b")");
                topics[0] = B256::from(keccak256(&signature));

                (data, topics.iter().map(|t| t.0).collect())
            }
        }
    };

    TokenStream::from(expanded)
}

#[proc_macro_attribute]
pub fn show_streams(attr: TokenStream, item: TokenStream) -> TokenStream {
    println!("attr: \"{}\"", attr.to_string());
    println!("item: \"{}\"", item.to_string());
    item
}

#[proc_macro_attribute]
pub fn contract(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemImpl);
    let struct_name = if let syn::Type::Path(type_path) = &*input.self_ty {
        &type_path.path.segments.first().unwrap().ident
    } else {
        panic!("Expected a struct.");
    };

    let mut constructor = None;
    let mut public_methods: Vec<&ImplItemMethod> = Vec::new();

    // Iterate over the items in the impl block to find pub methods + constructor
    for item in input.items.iter() {
        if let ImplItem::Method(method) = item {
            if method.sig.ident == "new" {
                constructor = Some(method);
                // Constructor sanity checks 
                let info = MethodInfo::from(method);
                if !info.returns_self(&struct_name) {
                    panic!("Constructor must return Self")
                }
            } else if let syn::Visibility::Public(_) = method.vis {
                public_methods.push(method);
            }
        }
    }

    let input_methods: Vec<_> = public_methods
        .iter()
        .map(|method| quote! { #method })
        .collect();
    let mut match_arms: Vec<_> = public_methods.iter().map(|method| {
        let method_name = &method.sig.ident;
        let method_info = MethodInfo::from(*method);
        let method_selector = u32::from_be_bytes(
            helpers::generate_fn_selector(&method_info, None)
                .expect("Unable to generate fn selector")
        );
        let (arg_names, arg_types) = helpers::get_arg_props_skip_first(&method_info);

        // Check if there are payable methods
        let checks = if !is_payable(&method) {
            quote! {
                if eth_riscv_runtime::msg_value() > U256::from(0) {
                    panic!("Non-payable function");
                }
            }
        } else {
            quote! {}
        };

        // Check if the method has a return type
        let return_handling = match &method.sig.output {
            ReturnType::Default => {
                // No return value
                quote! { self.#method_name(#( #arg_names ),*); }
            }
           ReturnType::Type(_,_) => {
                match helpers::extract_wrapper_types(&method.sig.output) {
                    helpers::WrapperType::Result(_,_) => quote! {
                        let res = self.#method_name(#( #arg_names ),*);
                        match res {
                            Ok(success) => {
                                let result_bytes = success.abi_encode();
                                let result_size = result_bytes.len() as u64;
                                let result_ptr = result_bytes.as_ptr() as u64;
                                eth_riscv_runtime::return_riscv(result_ptr, result_size);
                            }
                            Err(err) => {
                                eth_riscv_runtime::revert_with_error(&err.abi_encode());
                            }
                        }
                    },
                    helpers::WrapperType::Option(_) => quote! {
                        match self.#method_name(#( #arg_names ),*) {
                            Some(success) => {
                                let result_bytes = success.abi_encode();
                                let result_size = result_bytes.len() as u64;
                                let result_ptr = result_bytes.as_ptr() as u64;
                                eth_riscv_runtime::return_riscv(result_ptr, result_size);
                            },
                            None => eth_riscv_runtime::revert(),
                        }
                    },
                    helpers::WrapperType::None => quote! {
                        let result = self.#method_name(#( #arg_names ),*);
                        let result_bytes = result.abi_encode();
                        let result_size = result_bytes.len() as u64;
                        let result_ptr = result_bytes.as_ptr() as u64;
                        eth_riscv_runtime::return_riscv(result_ptr, result_size);
                    }
                }
            }
        };

        quote! {
            #method_selector => {
                let (#( #arg_names ),*) = <(#( #arg_types ),*)>::abi_decode(calldata, true).expect("abi decode failed");
                #checks
                #return_handling
            }
        }
    }).collect();
    
    let emit_helper = quote! {
        #[macro_export]
        macro_rules! get_type_signature {
            ($arg:expr) => {
                $arg.sol_type_name().as_bytes()
            };
        }

        #[macro_export]
        macro_rules! emit {
            ($event:ident, $($field:expr),*) => {{
                use alloy_sol_types::SolValue;
                use alloy_core::primitives::{keccak256, B256, U256, I256};
                use alloc::vec::Vec;

                let mut signature = alloc::vec![];
                signature.extend_from_slice($event::NAME.as_bytes());
                signature.extend_from_slice(b"(");

                let mut first = true;
                let mut topics = alloc::vec![B256::default()];
                let mut data = Vec::new();

                $(
                    if !first { signature.extend_from_slice(b","); }
                    first = false;

                    signature.extend_from_slice(get_type_signature!($field));
                    let encoded = $field.abi_encode();

                    let field_ident = stringify!($field);
                    if $event::INDEXED_FIELDS.contains(&field_ident) && topics.len() < 4 {
                        topics.push(B256::from_slice(&encoded));
                    } else {
                        data.extend_from_slice(&encoded);
                    }
                )*

                signature.extend_from_slice(b")");
                topics[0] = B256::from(keccak256(&signature));

                if !data.is_empty() {
                    eth_riscv_runtime::emit_log(&data, &topics);
                } else if topics.len() > 1 {
                    let data = topics.pop().unwrap();
                    eth_riscv_runtime::emit_log(data.as_ref(), &topics);
                }
            }};
        }
    };

    // Generate the interface
    let interface_name = format_ident!("I{}", struct_name);
    let interface = helpers::generate_interface(
        &public_methods,
        &interface_name,
        None,
    );

    // Generate initcode for deployments + prepare constructor args for Deployable impl
    let deployment_code = helpers::generate_deployment_code(struct_name, constructor);
    let constructor_args = match constructor {
        Some(method) => {
            let method_info = MethodInfo::from(method);
            let (_args_names, arg_types) = helpers::get_arg_props_all(&method_info); 
            if arg_types.is_empty() {
                quote! { () }
            } else {
                quote! { (#(#arg_types),*) }
            }
        },
        None => quote! { () }
    };

    // Generate the complete output with module structure
    let output = quote! {
        use eth_riscv_runtime::*;
        use alloy_sol_types::SolValue;

        // Deploy module
        #[cfg(feature = "deploy")]
            pub mod deploy {
            use super::*;
            use alloy_sol_types::SolValue;
            use eth_riscv_runtime::*;

            #emit_helper
            #deployment_code

            impl Deployable for #struct_name {
                type ConstructorArgs = #constructor_args; 
                type Interface = #interface_name;
                
                fn interface(addr: Address) -> Self::Interface {
                    #interface_name::new(addr)
                }

                fn bytecode() -> &'static [u8] {
                    // TODO: make more robust
                    let contract_name = #struct_name.to_string().to_lowercase();
                    
                    // Look up the bytecode
                    match get_contract_bytecode(contract_name) {
                        Some((_, deploy)) => deploy,
                        None => panic!("No bytecode found for contract: {}", contract_name),
                    }
                }
            }
        }

        // Public interface module
        #[cfg(not(feature = "deploy"))]
        pub mod interface {
            use super::*;
            #interface
        }

        // Generate the call method implementation privately
        // only when not in `interface-only` mode
        #[cfg(not(any(feature = "deploy", feature = "interface-only")))]
        #[allow(non_local_definitions)]
        mod implementation {
            use super::*;
            use alloy_sol_types::SolValue;
            use eth_riscv_runtime::*;

            #emit_helper

            impl #struct_name { #(#input_methods)* }
            impl Contract for #struct_name {
                fn call(&mut self) {
                    self.call_with_data(&msg_data());
                }

                fn call_with_data(&mut self, calldata: &[u8]) {
                    let selector = u32::from_be_bytes([calldata[0], calldata[1], calldata[2], calldata[3]]);
                    let calldata = &calldata[4..];

                    match selector {
                        #( #match_arms )*
                        // TODO: constructor
                        _ => panic!("unknown method"),
                    }

                    return_riscv(0, 0);
                }
            }

            #[eth_riscv_runtime::entry]
            fn main() -> ! {
                let mut contract = #struct_name::default();
                contract.call();
                eth_riscv_runtime::return_riscv(0, 0)
            }
        }

        // Export initcode when `deploy` mode
        #[cfg(feature = "deploy")]
        pub use deploy::*;

        // Always export the interface when not deploying
        #[cfg(not(feature = "deploy"))]
        pub use interface::*;

        // Only export contract impl when not in `interface-only` or `deploy` modes
        #[cfg(not(any(feature = "deploy", feature = "interface-only")))]
        pub use implementation::*;
    };

    TokenStream::from(output)
}

// Empty macro to mark a method as payable
#[proc_macro_attribute]
pub fn payable(_attr: TokenStream, item: TokenStream) -> TokenStream {
    item
}

// Check if a method is tagged with the payable attribute
fn is_payable(method: &syn::ImplItemMethod) -> bool {
    method.attrs.iter().any(|attr| {
        if let Ok(syn::Meta::Path(path)) = attr.parse_meta() {
            if let Some(segment) = path.segments.first() {
                return segment.ident == "payable";
            }
        }
        false
    })
}

#[proc_macro_attribute]
pub fn interface(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemTrait);
    let args = parse_macro_input!(attr as InterfaceArgs);
    let trait_name = &input.ident;

    let methods: Vec<_> = input
        .items
        .iter()
        .map(|item| {
            if let TraitItem::Method(method) = item {
                method
            } else {
                panic!("Expected methods arguments")
            }
        })
        .collect();

    // Generate intreface implementation
    let interface = helpers::generate_interface(&methods, trait_name, args.rename);
    let output = quote! { #interface };

    TokenStream::from(output)
}

#[proc_macro_attribute]
pub fn storage(_attr: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let vis = &input.vis;

    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => {
                let output = quote! {
                    #vis struct #name;
                    impl #name { pub fn new() -> Self { Self {} } }
                };
                return TokenStream::from(output);
            }
        },
        _ => panic!("Storage derive only works on structs"),
    };

    // Generate the struct definition with the same fields
    let struct_fields = fields.iter().map(|f| {
        let name = &f.ident;
        let ty = &f.ty;
        quote! { pub #name: #ty }
    });

    // Generate initialization code for each field
    // TODO: PoC uses a naive strategy. Enhance to support complex types like tuples or custom structs.
    let init_fields = fields.iter().enumerate().map(|(i, f)| {
        let name = &f.ident;
        let slot = U256::from(i);
        let [limb0, limb1, limb2, limb3] = slot.as_limbs();
        quote! { #name: StorageLayout::allocate(#limb0, #limb1, #limb2, #limb3) }
    });

    let expanded = quote! {
        #vis struct #name { #(#struct_fields,)* }

        impl #name {
            pub fn default() -> Self {
                Self { #(#init_fields,)* }
            }
        }
    };

    TokenStream::from(expanded)
}


================================================
File: eth-riscv-interpreter/Cargo.toml
================================================
[package]
name = "eth-riscv-interpreter"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true

[dependencies]
rvemu = { git="https://github.com/r55-eth/rvemu.git"}

thiserror.workspace = true

goblin = { version = "0.8.2", features = ["std"] }

[dev-dependencies]
eyre.workspace = true


================================================
File: eth-riscv-interpreter/src/error.rs
================================================
//! RISC-V interpreter crate errors

pub type Result<T> = core::result::Result<T, Error>;

/// Error encountered on RISC-V interpreter setup
#[allow(clippy::enum_variant_names)]
#[derive(Debug, thiserror::Error)]
pub enum Error {
    /// [`goblin`] crate error representation
    #[error(transparent)]
    GoblinError(#[from] goblin::error::Error),
}


================================================
File: eth-riscv-interpreter/src/lib.rs
================================================
use rvemu::{bus::DRAM_BASE, dram::DRAM_SIZE, emulator::Emulator};

mod error;
pub use error::{Error, Result};

pub fn setup_from_elf(elf_data: &[u8], call_data: &[u8]) -> Result<Emulator> {
    let elf = goblin::elf::Elf::parse(elf_data)?;

    // Allocate 1MB for the call data
    let mut mem = vec![0; 1024 * 1024];
    {
        assert!(call_data.len() < mem.len() - 8);

        let (size_bytes, data_bytes) = mem.split_at_mut(8);
        size_bytes.copy_from_slice(&(call_data.len() as u64).to_le_bytes());
        data_bytes[..call_data.len()].copy_from_slice(call_data);
    }

    load_sections(&mut mem, &elf, elf_data);

    let mut emu = Emulator::new();

    emu.initialize_dram(mem);
    emu.initialize_pc(elf.header.e_entry);

    Ok(emu)
}

fn load_sections(mem: &mut Vec<u8>, elf: &goblin::elf::Elf, elf_data: &[u8]) {
    for ph in &elf.program_headers {
        if ph.p_type == goblin::elf::program_header::PT_LOAD {
            // The interpreter RAM is DRAM_SIZE starting at DRAM_BASE
            assert!(ph.p_vaddr >= DRAM_BASE);
            assert!(ph.p_memsz <= DRAM_SIZE);

            let start_vec = (ph.p_vaddr - DRAM_BASE) as usize;
            let start_offset = ph.p_offset as usize;

            let end_vec = start_vec + ph.p_memsz as usize;
            if mem.len() < end_vec {
                mem.resize(end_vec, 0);
            }

            // The data available to copy may be smaller than the required size
            let size_to_copy = ph.p_filesz as usize;
            mem[start_vec..(start_vec + size_to_copy)]
                .copy_from_slice(&elf_data[start_offset..(start_offset + size_to_copy)]);
        }
    }
}

#[cfg(test)]
mod tests {
    use rvemu::exception::Exception;

    use super::*;
    use std::fs;
    use std::process::Command;

    #[test]
    fn test_execute_elf() -> eyre::Result<()> {
        let runtime_path = "../asm-runtime-example/runtime";

        // Check if the runtime ELF exists; if not, run `make` to generate it
        if fs::metadata(runtime_path).is_err() {
            let status = Command::new("make")
                .current_dir("../asm-runtime-example")
                .status()?;

            // Check if the `make` command succeeded
            if !status.success() {
                panic!("`make` command failed. Please check if the prerequisites are installed.");
            }
        }

        let elf_data = fs::read(runtime_path)?;
        let mut emu = setup_from_elf(&elf_data, &[])?;
        let result = emu.start();
        assert_eq!(result, Err(Exception::EnvironmentCallFromMMode));
        let t0 = emu.cpu.xregs.read(5);
        let a0 = emu.cpu.xregs.read(10);
        let a1 = emu.cpu.xregs.read(11);
        // t0: 0, opcode for return, a0: memory address of data, a1: length of data, in bytes
        assert!(t0 == 0); // return opcode
        assert_eq!(a1, 8); // data returned should be a little-endian u64
        let data_bytes = emu.cpu.bus.get_dram_slice(a0..(a0 + a1)).unwrap();

        let data = u64::from_le_bytes(data_bytes.try_into()?);
        assert_eq!(data, 5);

        Ok(())
    }
}


================================================
File: eth-riscv-runtime/Cargo.toml
================================================
[package]
name = "eth-riscv-runtime"
version = "0.1.0"
edition = "2021"

[dependencies]
eth-riscv-syscalls = { path = "../eth-riscv-syscalls" }
riscv-rt = "0.12.2"

alloy-core = { version = "0.8.20", default-features = false }
alloy-sol-types = { version = "0.8.20", default-features = false }


================================================
File: eth-riscv-runtime/src/alloc.rs
================================================
//! A very simple global allocator.
//!
//! Allocates on a global array and never deallocates.

use core::{
    alloc::{GlobalAlloc, Layout},
    cell::Cell,
    ptr::{self, addr_of},
};

// Force C representation so that the large buffer is at the end.
// This might avoid access to memory with large gaps.
#[repr(C)]
struct FixedMemoryAllocator<const SIZE: usize> {
    next_available: Cell<usize>,
    mem_buffer: [u8; SIZE],
}

impl<const SIZE: usize> FixedMemoryAllocator<SIZE> {
    const fn new() -> Self {
        Self {
            mem_buffer: [0; SIZE],
            next_available: Cell::new(0),
        }
    }
}

unsafe impl<const SIZE: usize> GlobalAlloc for FixedMemoryAllocator<SIZE> {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        self.alloc_zeroed(layout)
    }

    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
        // Start address of the allocation array:
        let array_start = addr_of!(self.mem_buffer) as usize;

        // Address of the next free space:
        let next_ptr = array_start + self.next_available.get();

        // Align the pointer.
        let aligned_ptr = (next_ptr + layout.align() - 1) & !(layout.align() - 1);

        // Where this allocated space ends:
        let end_of_allocation_ptr = aligned_ptr + layout.size();

        // Calculates where the next allocation with start:
        let new_next_available = end_of_allocation_ptr - array_start;

        if new_next_available <= SIZE {
            self.next_available.set(new_next_available);
            aligned_ptr as *mut u8
        } else {
            ptr::null_mut()
        }
    }

    unsafe fn dealloc(&self, _: *mut u8, _: Layout) {
        // Do nothing. This allocator never deallocates.
    }
}

#[global_allocator]
static mut GLOBAL: FixedMemoryAllocator<{ 1024 * 1024 * 10 }> = FixedMemoryAllocator::new();

#[alloc_error_handler]
fn alloc_error(layout: Layout) -> ! {
    panic!(
        "memory allocation of {} bytes with alignment {} failed",
        layout.size(),
        layout.align()
    );
}


================================================
File: eth-riscv-runtime/src/block.rs
================================================
use alloy_core::primitives::U256;
use eth_riscv_syscalls::Syscall;
use core::arch::asm;

// Returns current block timestamp in seconds since Unix epoch
pub fn timestamp() -> U256 {
    let first: u64;
    let second: u64;
    let third: u64;
    let fourth: u64;
    unsafe {
        asm!("ecall", lateout("a0") first, lateout("a1") second, lateout("a2") third, lateout("a3") fourth, in("t0") u8::from(Syscall::Timestamp));
    }
    U256::from_limbs([first, second, third, fourth])
}

// Returns current block base fee (EIP-3198 and EIP-1559)
pub fn base_fee() -> U256 {
    let first: u64;
    let second: u64;
    let third: u64;
    let fourth: u64;
    unsafe {
        asm!("ecall", lateout("a0") first, lateout("a1") second, lateout("a2") third, lateout("a3") fourth, in("t0") u8::from(Syscall::BaseFee));
    }
    U256::from_limbs([first, second, third, fourth])
}

// Returns current chain ID
pub fn chain_id() -> u64 {
    let id: u64;
    unsafe {
        asm!("ecall", lateout("a0") id, in("t0") u8::from(Syscall::ChainId));
    }
    id
}

// Returns current block gas limit
pub fn gas_limit() -> U256 {
    let first: u64;
    let second: u64;
    let third: u64;
    let fourth: u64;
    unsafe {
        asm!("ecall", lateout("a0") first, lateout("a1") second, lateout("a2") third, lateout("a3") fourth, in("t0") u8::from(Syscall::GasLimit));
    }
    U256::from_limbs([first, second, third, fourth])
}

// Returns current block number
pub fn number() -> U256 {
    let first: u64;
    let second: u64;
    let third: u64;
    let fourth: u64;
    unsafe {
        asm!("ecall", lateout("a0") first, lateout("a1") second, lateout("a2") third, lateout("a3") fourth, in("t0") u8::from(Syscall::Number));
    }
    U256::from_limbs([first, second, third, fourth])
}

================================================
File: eth-riscv-runtime/src/call.rs
================================================
#![no_std]

extern crate alloc;
use alloc::vec::Vec;
use alloy_core::primitives::{Address, Bytes, U256};
use core::{arch::asm, marker::PhantomData};
use eth_riscv_syscalls::Syscall;

// Concrete types implementing the context traits
pub struct ReadOnly;
pub struct ReadWrite;

// Marker traits to determine call context
pub trait CallCtx {}
pub trait StaticCtx: CallCtx {}
pub trait MutableCtx: StaticCtx {}

impl CallCtx for ReadOnly {}
impl CallCtx for ReadWrite {}
impl StaticCtx for ReadOnly {}
impl StaticCtx for ReadWrite {}
impl MutableCtx for ReadWrite {}

// Marker trait to connect contract method context with call ctx
pub trait MethodCtx { type Allowed: CallCtx; }
impl<'a, T> MethodCtx for &'a T { type Allowed = ReadOnly; }
impl<'a, T> MethodCtx for &'a mut T { type Allowed = ReadWrite; }

// Types and traits to build a MethodCtx-aware interface
pub struct InterfaceBuilder<I> {
    pub address: Address,
    pub _phantom: PhantomData<I>,
}

pub trait InitInterface: Sized {
    fn new(address: Address) -> InterfaceBuilder<Self>;
}

// Key change: Add trait to convert between interface types
pub trait IntoInterface<T> {
    fn into_interface(self) -> T;
}

impl<I> InterfaceBuilder<I> {
    pub fn with_ctx<M: MethodCtx, T>(
        self,
        _: M
    ) -> T 
    where
        I: IntoInterface<T>,
        M: MethodCtx<Allowed = T::Context>,
        T: FromBuilder
    {
        let target_builder = InterfaceBuilder {
            address: self.address,
            _phantom: PhantomData,
        };
        T::from_builder(target_builder)
    }
}

pub trait FromBuilder: Sized {
    type Context: CallCtx;
    fn from_builder(builder: InterfaceBuilder<Self>) -> Self;
}


/// Trait for contracts to have an entry point for txs  
pub trait Contract {
    fn call(&mut self);
    fn call_with_data(&mut self, calldata: &[u8]);
}

pub fn call_contract(
    addr: Address,
    value: u64,
    data: &[u8],
    ret_size: Option<u64>,
) -> Bytes {
    // Perform the call without writing return data into (REVM) memory
    call(addr, value, data.as_ptr() as u64, data.len() as u64);
    // Load call output to memory
    handle_call_output(ret_size)
}

pub fn call(addr: Address, value: u64, data_offset: u64, data_size: u64) {
    let addr: U256 = addr.into_word().into();
    let addr = addr.as_limbs();
    unsafe {
        asm!(
            "ecall",
            in("a0") addr[0], in("a1") addr[1], in("a2") addr[2],
            in("a3") value, in("a4") data_offset, in("a5") data_size,
            in("t0") u8::from(Syscall::Call)
        );
    }
}

pub fn staticcall_contract(addr: Address, value: u64, data: &[u8], ret_size: Option<u64>) -> Bytes {
    // Perform the staticcall without writing return data into (REVM) memory
    staticcall(addr, value, data.as_ptr() as u64, data.len() as u64);
    // Load call output to memory
    handle_call_output(ret_size)
}

fn handle_call_output(ret_size: Option<u64>) -> Bytes {
    // Figure out return data size + initialize memory location
    let ret_size = match ret_size {
        Some(size) => size,
        None => return_data_size(),
    };
  
    if ret_size == 0 {
        return Bytes::default()
    };

    let mut ret_data = Vec::with_capacity(ret_size as usize);
    ret_data.resize(ret_size as usize, 0);

    // Copy the return data from the interpreter's buffer
    let (offset, chunks, remainder) = (ret_data.as_ptr() as u64, ret_size / 32, ret_size % 32);

    // handle full chunks
    for i in 0..chunks {
        let step = i * 32;
        return_data_copy(offset + step, step, 32);
    };

    // handle potential last partial-chunk
    if remainder != 0 {
        let step = chunks * 32;
        return_data_copy(offset + step, step, remainder);
    };

    Bytes::from(ret_data)
}

pub fn staticcall(addr: Address, value: u64, data_offset: u64, data_size: u64) {
    let addr: U256 = addr.into_word().into();
    let addr = addr.as_limbs();
    unsafe {
        asm!(
            "ecall",
            in("a0") addr[0], in("a1") addr[1], in("a2") addr[2],
            in("a3") value, in("a4") data_offset, in("a5") data_size,
            in("t0") u8::from(Syscall::StaticCall)
        );
    }
}

pub fn return_data_size() -> u64 {
    let size: u64;
    unsafe {
        asm!( "ecall", lateout("a0") size, in("t0") u8::from(Syscall::ReturnDataSize));
    }

    size
}

pub fn return_data_copy(dest_offset: u64, res_offset: u64, res_size: u64) {
    unsafe {
        asm!(
            "ecall",
            in("a0") dest_offset, in("a1") res_offset, in("a2") res_size, in("t0")
            u8::from(Syscall::ReturnDataCopy)
        );
    }
}


================================================
File: eth-riscv-runtime/src/create.rs
================================================
#![no_std]

extern crate alloc;
use alloy_core::primitives::{Address, Bytes, U32};
use alloy_sol_types::{SolType, SolValue};
use ext_alloc::vec::Vec;
use core::arch::asm;
use eth_riscv_syscalls::Syscall;
use super::{CallCtx, MutableCtx};

pub trait Deployable {
    type Interface;
    type ConstructorArgs: SolValue
        + core::convert::From<<<Self::ConstructorArgs as SolValue>::SolType as SolType>::RustType>;

    /// Creates an interface instance from a contract address
    fn interface(addr: Address) -> Self::Interface;

    /// Returns the contract bytecode
    fn bytecode() -> &'static [u8];

    /// Deploys a new contract instance
    fn deploy(args: Self::ConstructorArgs) -> Self::Interface {
        let bytecode = Self::bytecode();
        let encoded_args = args.abi_encode();

        // Craft R55 initcode: [0xFF][codesize][bytecode][constructor_args]
        let codesize = U32::from(bytecode.len());

        let mut init_code = Vec::new();
        init_code.push(0xff);
        init_code.extend_from_slice(&Bytes::from(codesize.to_be_bytes_vec()));
        init_code.extend_from_slice(bytecode);
        init_code.extend_from_slice(&encoded_args);

        let offset = init_code.as_ptr() as u64;
        let size = init_code.len() as u64;
        // TODO: think of an ergonomic API to handle deployments with values
        let addr = create(0, offset, size);

        Self::interface(addr)
    }
}

pub fn create(value: u64, data_offset: u64, data_size: u64) -> Address {
    let (first, second, third): (u64, u64, u64);
    unsafe {
        asm!(
            "ecall",
            in("a0") value, in("a1") data_offset, in("a2") data_size,
            lateout("a0") first, lateout("a1") second, lateout("a2") third,
            in("t0") u8::from(Syscall::Create)
        );
    }
    let mut bytes = [0u8; 20];
    bytes[0..8].copy_from_slice(&first.to_be_bytes());
    bytes[8..16].copy_from_slice(&second.to_be_bytes());
    bytes[16..20].copy_from_slice(&third.to_be_bytes()[..4]);
    Address::from_slice(&bytes)
}


================================================
File: eth-riscv-runtime/src/error.rs
================================================
#![no_std]

extern crate alloc;
use alloc::vec::Vec;
use core::arch::asm;
use crate::Syscall;

pub trait Error {
    fn abi_encode(&self) -> Vec<u8>;
    fn abi_decode(bytes: &[u8], validate: bool) -> Self;
}

pub fn revert() -> ! { revert_with_error(Vec::new().as_slice()) }
pub fn revert_with_error(data: &[u8]) -> ! {
    let (offset, size) = (data.as_ptr() as u64, data.len() as u64);
    unsafe {
        asm!("ecall",
            in("a0") offset, in("a1") size,
            in("t0") u8::from(Syscall::Revert));
    }
    unreachable!()
}


================================================
File: eth-riscv-runtime/src/lib.rs
================================================
#![no_std]
#![no_main]
#![feature(alloc_error_handler, maybe_uninit_write_slice, round_char_boundary)]

use alloy_core::primitives::{Address, U256};
use core::{arch::asm, fmt::Write, panic::PanicInfo, slice};
pub use riscv_rt::entry;
extern crate alloc as ext_alloc;

mod alloc;
pub mod block;
pub mod tx;
pub mod types;

pub mod error;
pub use error::{revert, revert_with_error, Error};

pub mod log;
pub use log::{emit_log, Event};

pub mod create;
pub use create::{Deployable, create};

pub mod call;
pub use call::*;

const CALLDATA_ADDRESS: usize = 0x8000_0000;

pub unsafe fn slice_from_raw_parts(address: usize, length: usize) -> &'static [u8] {
    slice::from_raw_parts(address as *const u8, length)
}

#[panic_handler]
unsafe fn panic(info: &PanicInfo<'_>) -> ! {
    static mut IS_PANICKING: bool = false;

    if !IS_PANICKING {
        IS_PANICKING = true;

        // Capture the panic info msg
        let mut message = ext_alloc::string::String::new();
        let _ = write!(message, "{:?}", info.message());

        // Convert to bytes and revert
        let msg = message.into_bytes();
        revert_with_error(&msg);
    } else {
        revert_with_error("Panic handler has panicked!".as_bytes())
    }
}

use eth_riscv_syscalls::Syscall;

pub fn return_riscv(addr: u64, offset: u64) -> ! {
    unsafe {
        asm!("ecall", in("a0") addr, in("a1") offset, in("t0") u8::from(Syscall::Return));
    }
    unreachable!()
}

pub fn sload(key: U256) -> U256 {
    let key = key.as_limbs();
    let (val0, val1, val2, val3): (u64, u64, u64, u64);
    unsafe {
        asm!(
            "ecall",
            lateout("a0") val0, lateout("a1") val1, lateout("a2") val2, lateout("a3") val3,
            in("a0") key[0], in("a1") key[1], in("a2") key[2], in("a3") key[3],
            in("t0") u8::from(Syscall::SLoad));
    }
    U256::from_limbs([val0, val1, val2, val3])
}

pub fn sstore(key: U256, value: U256) {
    let key = key.as_limbs();
    let value = value.as_limbs();

    unsafe {
        asm!(
            "ecall",
            in("a0") key[0], in("a1") key[1], in("a2") key[2], in("a3") key[3],
            in("a4") value[0], in("a5") value[1], in("a6") value[2], in("a7") value[3],
            in("t0") u8::from(Syscall::SStore)
        );
    }
}

pub fn keccak256(offset: u64, size: u64) -> U256 {
    let (first, second, third, fourth): (u64, u64, u64, u64);
    unsafe {
        asm!(
            "ecall",
            in("a0") offset,
            in("a1") size,
            lateout("a0") first,
            lateout("a1") second,
            lateout("a2") third,
            lateout("a3") fourth,
            in("t0") u8::from(Syscall::Keccak256)
        );
    }
    U256::from_limbs([first, second, third, fourth])
}

pub fn msg_sender() -> Address {
    let (first, second, third): (u64, u64, u64);
    unsafe {
        asm!("ecall", lateout("a0") first, lateout("a1") second, lateout("a2") third, in("t0") u8::from(Syscall::Caller));
    }
    let mut bytes = [0u8; 20];
    bytes[0..8].copy_from_slice(&first.to_be_bytes());
    bytes[8..16].copy_from_slice(&second.to_be_bytes());
    bytes[16..20].copy_from_slice(&third.to_be_bytes()[..4]);
    Address::from_slice(&bytes)
}

pub fn msg_value() -> U256 {
    let (first, second, third, fourth): (u64, u64, u64, u64);
    unsafe {
        asm!("ecall", lateout("a0") first, lateout("a1") second, lateout("a2") third, lateout("a3") fourth, in("t0") u8::from(Syscall::CallValue));
    }
    U256::from_limbs([first, second, third, fourth])
}

pub fn msg_sig() -> [u8; 4] {
    let sig = unsafe { slice_from_raw_parts(CALLDATA_ADDRESS + 8, 4) };
    sig.try_into().unwrap()
}

pub fn msg_data() -> &'static [u8] {
    let length = unsafe { slice_from_raw_parts(CALLDATA_ADDRESS, 8) };
    let length = u64::from_le_bytes([
        length[0], length[1], length[2], length[3], length[4], length[5], length[6], length[7],
    ]) as usize;
    unsafe { slice_from_raw_parts(CALLDATA_ADDRESS + 8, length) }
}

#[allow(non_snake_case)]
#[no_mangle]
fn DefaultHandler() {
    panic!("default handler");
}

#[allow(non_snake_case)]
#[no_mangle]
fn ExceptionHandler(_trap_frame: &riscv_rt::TrapFrame) -> ! {
    panic!("exception nhandler");
}


================================================
File: eth-riscv-runtime/src/log.rs
================================================
#![no_std]

extern crate alloc;
use alloc::vec::Vec;
use alloy_core::primitives::B256;
use core::arch::asm;
use crate::Syscall;

pub trait Event {
    fn encode_log(&self) -> (Vec<u8>, Vec<[u8; 32]>);
}

pub fn emit<T: Event>(event: T) {
    let (data, topics) = event.encode_log();
    emit_log(&data, &topics.iter().map(|t| B256::from_slice(t)).collect::<Vec<_>>());
}

pub fn emit_log(data: &[u8], topics: &[B256]) {
    let mut all_topics = [0u8; 96];
    let topics = &topics[..topics.len().min(3)];
    for (i, topic) in topics.iter().enumerate() {
        let start = i * 32;
        all_topics[start..start + 32].copy_from_slice(topic.as_ref());
    }

    log(
        data.as_ptr() as u64,
        data.len() as u64,
        all_topics.as_ptr() as u64,
        topics.len() as u64 
    );
}

pub fn log(data_ptr: u64, data_size: u64, topics_ptr: u64, topics_size: u64) {
    unsafe {
        asm!(
            "ecall",
            in("a0") data_ptr,
            in("a1") data_size,
            in("a2") topics_ptr,
            in("a3") topics_size,
            in("t0") u8::from(Syscall::Log)
        );
    }
}


================================================
File: eth-riscv-runtime/src/tx.rs
================================================
use alloy_core::primitives::{Address, U256};
use core::arch::asm;
use eth_riscv_syscalls::Syscall;

// Returns the gas price of the current transaction
pub fn gas_price() -> U256 {
    let first: u64;
    let second: u64;
    let third: u64;
    let fourth: u64;
    unsafe { asm!("ecall", lateout("a0") first, lateout("a1") second, lateout("a2") third, lateout("a3") fourth, in("t0") u8::from(Syscall::GasPrice)) }
    U256::from_limbs([first, second, third, fourth])
}

// Returns sender of the transaction (full call chain)
pub fn origin() -> Address {
    let first: u64;
    let second: u64;
    let third: u64;
    unsafe {
        asm!("ecall", lateout("a0") first, lateout("a1") second, lateout("a2") third, in("t0") u8::from(Syscall::Origin));
    }
    let mut bytes = [0u8; 20];
    bytes[0..8].copy_from_slice(&first.to_be_bytes());
    bytes[8..16].copy_from_slice(&second.to_be_bytes());
    bytes[16..20].copy_from_slice(&third.to_be_bytes()[..4]);
    Address::from_slice(&bytes)
}

================================================
File: eth-riscv-runtime/src/types/mapping.rs
================================================
use super::*;

/// Implements a Solidity-like Mapping type.
#[derive(Default)]
pub struct Mapping<K, V> {
    id: U256,
    _pd: PhantomData<(K, V)>,
}

impl<K, V> StorageLayout for Mapping<K, V> {
    fn allocate(first: u64, second: u64, third: u64, fourth: u64) -> Self {
        Self {
            id: U256::from_limbs([first, second, third, fourth]),
            _pd: PhantomData::default(),
        }
    }
}

impl<K, V> Mapping<K, V>
where
    K: SolValue,
{
    pub fn encode_key(&self, key: K) -> U256 {
        let key_bytes = key.abi_encode();
        let id_bytes: [u8; 32] = self.id.to_be_bytes();

        // Concatenate the key bytes and id bytes
        let mut concatenated = Vec::with_capacity(key_bytes.len() + id_bytes.len());
        concatenated.extend_from_slice(&key_bytes);
        concatenated.extend_from_slice(&id_bytes);

        // Call the keccak256 syscall with the concatenated bytes
        let offset = concatenated.as_ptr() as u64;
        let size = concatenated.len() as u64;

        keccak256(offset, size)
    }
}

// Implementation for mappings that wrap `StorageStorable` types 
impl<K, T, V> KeyValueStorage<K> for Mapping<K, T>
where
    K: SolValue,
    T: StorageStorable<Value = V>,
    V: SolValue + core::convert::From<<<V as SolValue>::SolType as SolType>::RustType>,
{
    type ReadValue = V;
    type WriteValue = V;

    fn read(&self, key: K) -> Self::ReadValue {
        T::__read(self.encode_key(key))
    }

    fn write(&mut self, key: K, value: Self::WriteValue) {
        T::__write(self.encode_key(key), value)
    }
}

// Implementation for nested mappings
impl<K1, K2, V> KeyValueStorage<K1> for Mapping<K1, Mapping<K2, V>>
where
    K1: SolValue,
{
    type ReadValue = Mapping<K2, V>;
    type WriteValue = ();

    fn read(&self, key: K1) -> Self::ReadValue {
        Mapping {
            id: self.encode_key(key),
            _pd: PhantomData,
        }
    }

    // Mappings that store other mappings cannot be written to
    // Only the lowest level mapping can store values on its `StorageStorable` wrapped type
    fn write(&mut self, _key: K1, _value: Self::WriteValue) {
        revert();
    }
}


================================================
File: eth-riscv-runtime/src/types/mod.rs
================================================
use core::default::Default;
use core::marker::PhantomData;

use crate::*;

use alloy_sol_types::{SolType, SolValue};

extern crate alloc;
use alloc::vec::Vec;

mod mapping;
pub use mapping::Mapping;

mod slot;
pub use slot::Slot;

///  STORAGE TYPES:
///  > Must implement the following traits:
///     - `StorageLayout`: Allows the `storage` macro to allocate a storage slot.
///  > Must implement one of the following traits, for external consumption:
///     - `DirectStorage`:  Exposes read and write capabilities of values that are directly accessed.
///     - `KeyValueStorage`:  Exposes read and write capabilities of values that are accesed by key.
///  > Unless it is a wrapper type (like `Mapping`) it must implement the following traits:
///     - `StorageStorable`: Allows db storage reads and writes with abi de/encoding.


// TODO: enhance `storage` macro to handle complex types (like tuples or custom structs)
/// A trait for storage types that require a dedicated slot in the storage layout
pub trait StorageLayout {
    fn allocate(limb0: u64, limb1: u64, limb2: u64, limb3: u64) -> Self;
}

/// Internal trait, for low-level storage operations.
pub trait StorageStorable {
    type Value: SolValue
        + core::convert::From<<<Self::Value as SolValue>::SolType as SolType>::RustType>;

    fn __read(key: U256) -> Self::Value;
    fn __write(key: U256, value: Self::Value);
}

/// Public interface for direct storage types (like `Slot`)
pub trait DirectStorage<V>
where
    Self: StorageStorable<Value = V>,
{
    fn read(&self) -> V;
    fn write(&mut self, value: V);
}

/// Public interface for key-value storage types (like `Mapping`)
pub trait KeyValueStorage<K> {
    type ReadValue;
    type WriteValue;

    fn read(&self, key: K) -> Self::ReadValue;
    fn write(&mut self, key: K, value: Self::WriteValue);
}


================================================
File: eth-riscv-runtime/src/types/slot.rs
================================================
use super::*;

use core::ops::{Add, AddAssign, Sub, SubAssign};

/// Wrapper around `alloy::primitives` that can be written in a single slot (single EVM word).
#[derive(Default)]
pub struct Slot<V> {
    id: U256,
    _pd: PhantomData<V>,
}

impl<V> StorageLayout for Slot<V> {
    fn allocate(first: u64, second: u64, third: u64, fourth: u64) -> Self {
        Self {
            id: U256::from_limbs([first, second, third, fourth]),
            _pd: PhantomData::default(),
        }
    }
}

impl<V> StorageStorable for Slot<V>
where
    V: SolValue + core::convert::From<<<V as SolValue>::SolType as SolType>::RustType>,
{
    type Value = V;

    fn __read(key: U256) -> Self::Value {
        let bytes: [u8; 32] = sload(key).to_be_bytes();
        V::abi_decode(&bytes, false).unwrap_or_else(|_| revert())
    }

    fn __write(key: U256, value: Self::Value) {
        let bytes = value.abi_encode();
        let mut padded = [0u8; 32];
        padded[..bytes.len()].copy_from_slice(&bytes);
        sstore(key, U256::from_be_bytes(padded));
    }
}

impl<V> DirectStorage<V> for Slot<V>
where
    Self: StorageStorable<Value = V>,
{
    fn read(&self) -> V {
        Self::__read(self.id)
    }

    fn write(&mut self, value: V) {
        Self::__write(self.id, value)
    }
}

// Implementation of several std traits to improve dev-ex
impl<V> Add<V> for Slot<V>
where
    Self: StorageStorable<Value = V>,
    V: core::ops::Add<Output = V>,
{
    type Output = V;
    fn add(self, rhs: V) -> V {
        self.read() + rhs
    }
}

impl<V> AddAssign<V> for Slot<V>
where
    Self: StorageStorable<Value = V>,
    V: core::ops::Add<Output = V>,
{
    fn add_assign(&mut self, rhs: V) {
        self.write(self.read() + rhs)
    }
}

impl<V> Sub<V> for Slot<V>
where
    Self: StorageStorable<Value = V>,
    V: core::ops::Sub<Output = V>,
{
    type Output = V;
    fn sub(self, rhs: V) -> V {
        self.read() - rhs
    }
}

impl<V> SubAssign<V> for Slot<V>
where
    Self: StorageStorable<Value = V>,
    V: core::ops::Sub<Output = V>,
{
    fn sub_assign(&mut self, rhs: V) {
        self.write(self.read() - rhs)
    }
}

impl<V> PartialEq for Slot<V>
where
    Self: StorageStorable<Value = V>,
    V: StorageStorable + PartialEq,
{
    fn eq(&self, other: &Self) -> bool {
        self.read() == other.read()
    }
}


================================================
File: eth-riscv-syscalls/Cargo.toml
================================================
[package]
name = "eth-riscv-syscalls"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true

[dependencies]
thiserror-no-std = "2.0.2"


================================================
File: eth-riscv-syscalls/src/error.rs
================================================
use alloc::borrow::Cow;

/// Error related to syscall convertions
#[derive(Debug, thiserror_no_std::Error)]
pub enum Error {
    #[error("Unknown syscall opcode: {0}")]
    UnknownOpcode(u8),
    #[error("Parse error for syscall string. Input: {input}")]
    ParseError { input: Cow<'static, str> },
}


================================================
File: eth-riscv-syscalls/src/lib.rs
================================================
#![no_std]

extern crate alloc;

mod error;
pub use error::Error;

macro_rules! syscalls {
    ($(($num:expr, $identifier:ident, $name:expr)),* $(,)?) => {
        #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
        #[repr(u8)]
        pub enum Syscall {
            $($identifier = $num),*
        }

        impl core::fmt::Display for Syscall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", match self {
                    $(Syscall::$identifier => $name),*
                })
            }
        }

        impl core::str::FromStr for Syscall {
            type Err = Error;
            fn from_str(input: &str) -> Result<Self, Self::Err> {
                match input {
                    $($name => Ok(Syscall::$identifier)),*,
                    name => Err(Error::ParseError { input: alloc::string::String::from(name).into() }),
                }
            }
        }

        impl From<Syscall> for u8 {
            fn from(syscall: Syscall) -> Self {
                syscall as Self
            }
        }

        impl core::convert::TryFrom<u8> for Syscall {
            type Error = Error;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                match value {
                    $($num => Ok(Syscall::$identifier)),*,
                    num => Err(Error::UnknownOpcode(num)),
                }
            }
        }
    }
}

// Generate `Syscall` enum with supported syscalls and their ids.
//
// The opcode for each syscall matches the corresponding EVM opcode,
// as described on https://www.evm.codes.
//
// t0: 0x20, opcode for keccak256, a0: offset, a1: size, returns keccak256 hash
// t0: 0x32, opcode for origin, returns an address
// t0: 0x33, opcode for caller, returns an address
// t0: 0x34, opcode for callvalue, a0: first limb, a1: second limb, a2: third limb, a3: fourth limb, returns 256-bit value
// t0: 0x3A, opcode for gasprice, returns 256-bit value
// t0: 0x3d, opcode for returndatasize, returns 64-bit value
// t0: 0x3e, opcode for returndatacopy, a0: memory offset, a1: return data offset, a2: return data size, returns nothing
// t0: 0x54, opcode for sload, a0: storage key, returns 256-bit value
// t0: 0x55, opcode for sstore, a0-a3: 256-bit storage key, a4-a7: 256-bit storage value, returns nothing
// t0: 0xf0, opcode for create, args: a0: 64-bit value, a1: calldata offset, a2: calldata size, returns an address
// t0: 0xf1, opcode for call, args: a0-a2: address, a3: 64-bit value, a4: calldata offset, a5: calldata size
// t0: 0xfa, opcode for staticcall, args: a0-a2: address, a3: 64-bit value, a4: calldata offset, a5: calldata size
// t0: 0xf3, opcode for return, a0: memory address of data, a1: length of data in bytes, doesn't return
// t0: 0xfd, opcode for revert, doesn't return
syscalls!(
    (0x20, Keccak256, "keccak256"),
    (0x32, Origin, "origin"),
    (0x33, Caller, "caller"),
    (0x34, CallValue, "callvalue"),
    (0x3A, GasPrice, "gasprice"),
    (0x3D, ReturnDataSize, "returndatasize"),
    (0x3E, ReturnDataCopy, "returndatacopy"),
    (0x42, Timestamp, "timestamp"),
    (0x43, Number, "number"),
    (0x45, GasLimit, "gaslimit"),
    (0x46, ChainId, "chainid"),
    (0x48, BaseFee, "basefee"),
    (0x54, SLoad, "sload"),
    (0x55, SStore, "sstore"),
    (0xf0, Create, "create"),
    (0xf1, Call, "call"),
    (0xfa, StaticCall, "staticcall"),
    (0xf3, Return, "return"),
    (0xfd, Revert, "revert"),
    (0xA0, Log, "log"),
);


================================================
File: examples/erc20/Cargo.toml
================================================
[package]
name = "erc20"
version = "0.1.0"
edition = "2021"

[workspace]

[features]
default = []
deploy = []
interface-only = []

[dependencies]
contract-derive = { path = "../../contract-derive" }
eth-riscv-runtime = { path = "../../eth-riscv-runtime" }

alloy-core = { version = "0.8.20", default-features = false }
alloy-sol-types = { version = "0.8.20", default-features = false }

[[bin]]
name = "runtime"
path = "src/lib.rs"

[[bin]]
name = "deploy"
path = "src/lib.rs"
required-features = ["deploy"]

[profile.release]
lto = true
opt-level = "z"


================================================
File: examples/erc20/src/lib.rs
================================================
#![no_std]
#![no_main]

use core::default::Default;

use contract_derive::{contract, payable, storage, Event, Error};
use eth_riscv_runtime::types::*;

use alloy_core::primitives::{address, Address, Bytes, U256};

extern crate alloc;
use alloc::string::String;

// -- EVENTS -------------------------------------------------------------------
#[derive(Event)]
pub struct Transfer {
    #[indexed]
    pub from: Address,
    #[indexed]
    pub to: Address,
    pub amount: U256,
}

#[derive(Event)]
pub struct Approval {
    #[indexed]
    pub owner: Address,
    #[indexed]
    pub spender: Address,
    pub amount: U256,
}

#[derive(Event)]
pub struct OwnershipTransferred {
    #[indexed]
    pub from: Address,
    #[indexed]
    pub to: Address,
}

// -- ERRORS -------------------------------------------------------------------
#[derive(Error)]
pub enum ERC20Error {
    OnlyOwner,
    InsufficientBalance(U256),
    InsufficientAllowance(U256),
    SelfApproval,
    SelfTransfer,
    ZeroAmount,
    ZeroAddress,
}

// -- CONTRACT -----------------------------------------------------------------
#[storage]
pub struct ERC20 {
    total_supply: Slot<U256>,
    balance_of: Mapping<Address, Slot<U256>>,
    allowance_of: Mapping<Address, Mapping<Address, Slot<U256>>>,
    owner: Slot<Address>,
    // TODO: handle string storage
    // name: String, 
    // symbol: String,
    // decimals: u8,
}

#[contract]
impl ERC20 {
    // -- CONSTRUCTOR ----------------------------------------------------------
    pub fn new(owner: Address) -> Self {
        // Init the contract
        let mut erc20 = ERC20::default();

        // Update state
        erc20.owner.write(owner);

        // Return the initialized contract
        erc20
    }

    // -- STATE MODIFYING FUNCTIONS --------------------------------------------
    #[payable]
    pub fn mint(&mut self, to: Address, amount: U256) -> Result<bool, ERC20Error> {
        // Perform sanity checks
        if msg_sender() != self.owner.read() { return Err(ERC20Error::OnlyOwner) }; 
        if amount == U256::ZERO { return Err(ERC20Error::ZeroAmount) };
        if to == Address::ZERO { return Err(ERC20Error::ZeroAddress) };

        // Increase user balance
        let to_balance = self.balance_of.read(to);
        self.balance_of.write(to, to_balance + amount);

        // Increase total supply
        self.total_supply += amount;
        
        // Emit event + return `true` to stick to (EVM) ERC20 convention
        log::emit(Transfer::new(Address::ZERO, to, amount));
        Ok(true)
    }

    pub fn approve(&mut self, spender: Address, amount: U256) -> Result<bool, ERC20Error> {
        let owner = msg_sender();

        // Perform sanity checks
        if spender == Address::ZERO { return Err(ERC20Error::ZeroAddress) };
        if spender == owner { return Err(ERC20Error::SelfApproval) };

        // Update state
        let mut spender_allowances = self.allowance_of.read(owner);
        spender_allowances.write(spender, amount);

        // Emit event + return 
        log::emit(Approval::new(owner, spender, amount));
        Ok(true)
    }

    pub fn transfer(&mut self, to: Address, amount: U256) -> Result<bool, ERC20Error> {
        let from = msg_sender();

        // Perform sanity checks
        if to == Address::ZERO { return Err(ERC20Error::ZeroAddress) };
        if amount == U256::ZERO { return Err(ERC20Error::ZeroAmount) };
        if from == to { return Err(ERC20Error::SelfTransfer) };

        // Read user balances
        let from_balance = self.balance_of.read(from);
        let to_balance = self.balance_of.read(to);

        // Ensure enough balance
        if from_balance < amount { return Err(ERC20Error::InsufficientBalance(from_balance)) }

        // Update state
        self.balance_of.write(from, from_balance - amount);
        self.balance_of.write(to, to_balance + amount);

        // Emit event + return 
        log::emit(Transfer::new(from, to, amount));
        Ok(true)
    }

    pub fn transfer_from(&mut self, from: Address, to: Address, amount: U256) -> Result<bool, ERC20Error> {
        let msg_sender = msg_sender();

        // Perform sanity checks
        if to == Address::ZERO { return Err(ERC20Error::ZeroAddress) };
        if amount == U256::ZERO { return Err(ERC20Error::ZeroAmount) };
        if from == to { return Err(ERC20Error::SelfTransfer) };

        // Ensure enough allowance
        let allowance = self.allowance_of.read(from).read(msg_sender);
        if allowance < amount { return Err(ERC20Error::InsufficientAllowance(allowance)) };

        // Ensure enough balance
        let from_balance = self.balance_of.read(from);
        if from_balance < amount { return Err(ERC20Error::InsufficientBalance(from_balance)) };

        // Update state
        self.allowance_of
            .read(from)
            .write(msg_sender, allowance - amount);
        self.balance_of.write(from, from_balance - amount);
        self.balance_of.write(to, self.balance_of.read(to) + amount);

        // Emit event + return 
        log::emit(Transfer::new(from, to, amount));
        Ok(true)
    }

    pub fn transfer_ownership(&mut self, new_owner: Address) -> Result<bool, ERC20Error> {
        let from = msg_sender();

        // Perform safety check 
        if from != self.owner.read() { return Err(ERC20Error::OnlyOwner) }; 
        if from == new_owner { return Err(ERC20Error::SelfTransfer) }; 

        // Update state
        self.owner.write(new_owner);

        // Emit event + return 
        log::emit(OwnershipTransferred::new(from, new_owner));
        Ok(true)
    }

    // -- READ-ONLY FUNCTIONS --------------------------------------------------
    pub fn owner(&self) -> Address {
        self.owner.read()
    }

    pub fn total_supply(&self) -> U256 {
        self.total_supply.read()
    }

    pub fn balance_of(&self, owner: Address) -> U256 {
        self.balance_of.read(owner)
    }

    pub fn allowance(&self, owner: Address, spender: Address) -> U256 {
        self.allowance_of.read(owner).read(spender)
    }
}


================================================
File: examples/erc20x/Cargo.toml
================================================
[package]
name = "erc20x"
version = "0.1.0"
edition = "2021"

[workspace]

[features]
default = []
deploy = []
interface-only = []

[dependencies]
contract-derive = { path = "../../contract-derive" }
eth-riscv-runtime = { path = "../../eth-riscv-runtime" }
erc20 = { path = "../erc20", features = ["deploy"] }

alloy-core = { version = "0.8.20", default-features = false }
alloy-sol-types = { version = "0.8.20", default-features = false }

[[bin]]
name = "runtime"
path = "src/lib.rs"

[[bin]]
name = "deploy"
path = "src/lib.rs"
required-features = ["deploy"]

[profile.release]
lto = true
opt-level = "z"


================================================
File: examples/erc20x/src/lib.rs
================================================
#![no_std]
#![no_main]

use core::default::Default;

use alloy_core::primitives::{Address, U256};
use contract_derive::{contract, show_streams};

extern crate alloc;

use erc20::{ERC20, ERC20Error, IERC20};

#[derive(Default)]
pub struct ERC20x;

#[contract]
impl ERC20x {
    pub fn deploy(&mut self, owner: Address) -> Address {
        let token = ERC20::deploy(owner);                           // IERC20<ReadWrite>
        token.address
    }

    pub fn x_balance_of(&self, owner: Address, token_addr: Address) -> Option<U256> {
        let token = IERC20::new(token_addr).with_ctx(self);         // IERC20<ReadOnly>
        token.balance_of(owner)
    }

    pub fn x_mint(&mut self, to: Address, amount: U256, token_addr: Address) -> Result<bool, ERC20Error> {
        let mut token = IERC20::new(token_addr).with_ctx(self);     // IERC20<ReadWrite>
        token.mint(to, amount)
    }

    // pub fn x_mint_fails(&self, to: Address, token_addr: Address) -> Result<bool, ERC20Error> {
    //     let mut token = IERC20::new(token_addr).with_ctx(self);  // IERC20<ReadOnly>
    //     token.mint(to, amount)
    // }

    pub fn x_transfer_from(
        &mut self,
        from: Address,
        amount: U256,
        token_addr: Address
    ) -> Result<bool, ERC20Error> {
        let mut token = IERC20::new(token_addr).with_ctx(self);     // IERC20<ReadWrite>
        let to = msg_sender();

        // easily leverage rust's `Result<T, E>` enum to deal with call reverts
        match token.transfer_from(from, to, amount) {
            Err(ERC20Error::InsufficientBalance(max)) => token.transfer_from(from, to, max),
            Err(ERC20Error::InsufficientAllowance(max)) => token.transfer_from(from, to, max),
            other => other
        }
    }

    pub fn panics(&self) { panic!("This function always panics"); }

    pub fn x_mint_panics(&mut self, to: Address, amount: U256, token_addr: Address) -> bool {
        let mut token = IERC20::new(token_addr).with_ctx(self);     // IERC20<ReadWrite>
        token.mint(to, amount).expect("ERC20::mint() failed!")
    }
}


================================================
File: examples/erc721/Cargo.toml
================================================
[package]
name = "erc721"
version = "0.1.0"
edition = "2021"

[workspace]

[features]
default = []
deploy = []
interface-only = []

[dependencies]
contract-derive = { path = "../../contract-derive" }
eth-riscv-runtime = { path = "../../eth-riscv-runtime" }

alloy-core = { version = "0.8.20", default-features = false }
alloy-sol-types = { version = "0.8.20", default-features = false }

[[bin]]
name = "runtime"
path = "src/lib.rs"

[[bin]]
name = "deploy"
path = "src/lib.rs"
required-features = ["deploy"]

[profile.release]
lto = true
opt-level = "z"


================================================
File: examples/erc721/src/lib.rs
================================================
#![no_std]
#![no_main]

use core::default::Default;

use contract_derive::{contract, payable, storage, Event, Error};
use eth_riscv_runtime::types::*;

use alloy_core::primitives::{address, Address, U256, Bytes};

extern crate alloc;
use alloc::string::String;

// -- EVENTS -------------------------------------------------------------------
#[derive(Event)]
pub struct Transfer {
    #[indexed]
    pub from: Address,
    #[indexed]
    pub to: Address,
    #[indexed]
    pub id: U256,
}

#[derive(Event)]
pub struct Approval {
    #[indexed]
    pub owner: Address,
    #[indexed]
    pub spender: Address,
    #[indexed]
    pub id: U256,
}

#[derive(Event)]
pub struct ApprovalForAll {
    #[indexed]
    pub owner: Address,
    #[indexed]
    pub operator: Address,
    pub approved: bool,
}

#[derive(Event)]
pub struct OwnershipTransferred {
    #[indexed]
    pub from: Address,
    #[indexed]
    pub to: Address,
}

// -- ERRORS -------------------------------------------------------------------
#[derive(Error)]
pub enum ERC721Error {
    AlreadyMinted,
    NotMinted,
    OnlyOwner,
    Unauthorized,
    WrongFrom,
    ZeroAddress,
}

// -- CONTRACT -----------------------------------------------------------------
#[storage]
pub struct ERC721 {
    total_supply: Slot<U256>,
    owner_of: Mapping<U256, Slot<Address>>,
    balance_of: Mapping<Address, Slot<U256>>,
    approval_of: Mapping<U256, Slot<Address>>,
    is_operator: Mapping<Address, Mapping<Address, Slot<bool>>>,
    owner: Slot<Address>,
    // TODO: handle string storage
    // name: String, 
    // symbol: String,
}

#[contract]
impl ERC721 {
    // -- CONSTRUCTOR ----------------------------------------------------------
    pub fn new(owner: Address) -> Self {
        // Init the contract
        let mut erc721 = ERC721::default();

        // Store the owner
        erc721.owner.write(owner);

        // Return the initialized contract
        erc721
    }

    // -- STATE MODIFYING FUNCTIONS --------------------------------------------
    #[payable]
    pub fn mint(&mut self, to: Address, id: U256) -> Result<bool, ERC721Error> {
        // Perform sanity checks
        if to == Address::ZERO { return Err(ERC721Error::ZeroAddress) };
        if msg_sender() != self.owner.read() { return Err(ERC721Error::OnlyOwner) }; 
        if self.owner_of.read(id) != Address::ZERO { return Err(ERC721Error::AlreadyMinted) };

        // Update state
        self.owner_of.write(id, to);
        self.balance_of.write(to, self.balance_of.read(to) + U256::from(1));
        self.total_supply.write(self.total_supply.read() + U256::from(1));
        
        // Emit event + return
        log::emit(Transfer::new(Address::ZERO, to, id));
        Ok(true)
    }

    pub fn approve(&mut self, spender: Address, id: U256) -> Result<bool, ERC721Error> {
        let owner = self.owner_of.read(id);
        
        // Perform authorization check
        if msg_sender() != owner && !self.is_operator.read(owner).read(msg_sender()) {
            return Err(ERC721Error::Unauthorized);
        }

        // Update state
        self.approval_of.write(id, spender);

        // Emit event + return
        log::emit(Approval::new(owner, spender, id));
        Ok(true)
    }

    pub fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<bool, ERC721Error> {
        // Update state
        self.is_operator
            .read(msg_sender())
            .write(operator, approved);

        // Emit event + return
        log::emit(ApprovalForAll::new(msg_sender(), operator, approved));
        Ok(true)
    }

    pub fn transfer_from(&mut self, from: Address, to: Address, id: U256) -> Result<bool, ERC721Error> {
        // Perform sanity checks
        if from != self.owner_of.read(id) { return Err(ERC721Error::WrongFrom) };
        if to == Address::ZERO { return Err(ERC721Error::ZeroAddress) };

        // Check authorization
        let sender = msg_sender();
        if sender != from 
            && !self.is_operator.read(from).read(sender)
            && sender != self.approval_of.read(id) {
            return Err(ERC721Error::Unauthorized);
        }

        // Update state
        self.owner_of.write(id, to);
        self.balance_of.write(from, self.balance_of.read(from) - U256::from(1));
        self.balance_of.write(to, self.balance_of.read(to) + U256::from(1));
        self.approval_of.write(id, Address::ZERO);

        // Emit event + return
        log::emit(Transfer::new(from, to, id));
        Ok(true)
    }

    pub fn transfer_ownership(&mut self, new_owner: Address) -> Result<bool, ERC721Error> {
        // Perform safety check 
        let from = msg_sender();
        if from != self.owner.read() { return Err(ERC721Error::OnlyOwner) }; 

        // Update state
        self.owner.write(new_owner);

        // Emit event + return 
        log::emit(OwnershipTransferred::new(from, new_owner));
        Ok(true)
    }

    // -- READ-ONLY FUNCTIONS --------------------------------------------------
    pub fn owner(&self) -> Address {
        self.owner.read()
    }

    pub fn owner_of(&self, id: U256) -> Result<Address, ERC721Error> {
        let owner = self.owner_of.read(id);
        if owner == Address::ZERO {
            return Err(ERC721Error::NotMinted);
        }
        Ok(owner)
    }

    pub fn balance_of(&self, owner: Address) -> Result<U256, ERC721Error> {
        if owner == Address::ZERO {
            return Err(ERC721Error::ZeroAddress);
        }
        Ok(self.balance_of.read(owner))
    }

    pub fn get_approved(&self, id: U256) -> Address {
        self.approval_of.read(id)
    }

    pub fn is_approved_for_all(&self, owner: Address, operator: Address) -> bool {
        self.is_operator.read(owner).read(operator)
    }

    pub fn total_supply(&self) -> U256 {
        self.total_supply.read()
    }
}



================================================
File: examples/evm-caller/Cargo.toml
================================================
[package]
name = "evm-caller"
version = "0.1.0"
edition = "2021"

[workspace]

[features]
default = []
deploy = []
interface-only = []

[dependencies]
contract-derive = { path = "../../contract-derive" }
eth-riscv-runtime = { path = "../../eth-riscv-runtime" }

alloy-core = { version = "0.8.20", default-features = false }
alloy-sol-types = { version = "0.8.20", default-features = false }

[[bin]]
name = "runtime"
path = "src/lib.rs"

[[bin]]
name = "deploy"
path = "src/lib.rs"
required-features = ["deploy"]

[profile.release]
lto = true
opt-level = "z"


================================================
File: examples/evm-caller/src/lib.rs
================================================
#![no_std]
#![no_main]

use core::default::Default;

use alloy_core::primitives::{address, Bytes, Address, U256};
use contract_derive::{contract, interface};

extern crate alloc;
use alloc::{string::String, vec::Vec};

#[derive(Default)]
pub struct EVMCaller;

#[interface("camelCase")]
trait ISimpleStorage {
    fn get(&self) -> U256;
    fn set(&mut self, value: U256);
}

#[contract]
impl EVMCaller {
    pub fn x_set(&mut self, target: Address, value: U256) {
        ISimpleStorage::new(target).with_ctx(self).set(value);
    }

    pub fn x_get(&self, target: Address) -> U256 {
        ISimpleStorage::new(target).with_ctx(self).get().expect("Unable to get value")
    }
}


================================================
File: r55/Cargo.toml
================================================
[package]
name = "r55"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true

[dependencies]
eth-riscv-interpreter.workspace = true
eth-riscv-syscalls.workspace = true

revm = { version = "19.4.0", features = ["std"] }
rvemu = { git = "https://github.com/r55-eth/rvemu.git" }

alloy-core = "0.8.20"
alloy-primitives = "0.8.20"
alloy-sol-types = "0.8.20"

eyre.workspace = true
thiserror.workspace = true

tracing.workspace = true
tracing-subscriber.workspace = true


================================================
File: r55/build.rs
================================================
const GENERATED_CODE_PATH: &str = "src/generated";

pub fn main() {
    // Detect contracts
    let contracts = detect_contracts();
    
    // Compile each contract
    let bytecodes = compile_contracts(&contracts);
    
    // Generate Rust code with bytecode constants
    generate_bytecode_module(bytecodes);
    
    // Tell Cargo to rerun if any contract source changes
    for contract in contracts {
        println!("cargo:rerun-if-changed={}", contract.path);
    }
}

struct Contract {
    name: String,
    path: String,
}

fn detect_contracts() -> Vec<Contract> {
    // Several strategies for detection:
    
    // 1. Look for specific directory structure
    // 2. Parse Cargo.toml files for R55 dependencies
    // 3. Use environment variables to specify contracts
    // 4. Look for marker files or annotations
    
    // For now, we'll use a simple approach:
    // Look for directories with a specific structure
    
    let mut contracts = Vec::new();
    
    // Start from the workspace root
    let workspace_root = std::env::var("CARGO_MANIFEST_DIR")
        .expect("Failed to get manifest directory");
    
    // Look for contract directories
    // TODO: look for r55 dependencies
    for entry in std::fs::read_dir(workspace_root).expect("Failed to read directory") {
        let entry = entry.expect("Failed to read entry");
        let path = entry.path();
        
        if path.is_dir() && is_contract_directory(&path) {
            let name = path.file_name().unwrap().to_string_lossy().to_string();
            contracts.push(Contract { name, path: path.to_string_lossy().to_string() });
        }
    }
    
    contracts
}

fn is_contract_directory(path: &std::path::Path) -> bool {
    // Check for the presence of marker files or structure
    path.join("src").join("lib.rs").exists() &&
    (path.join("Cargo.toml").exists())
}

struct ContractBytecode {
    name: String,
    runtime_bytecode: Vec<u8>,
    deploy_bytecode: Vec<u8>,
}

fn compile_contracts(contracts: &Vec<Contract>) -> Vec<ContractBytecode> {
    let mut bytecodes = Vec::new();
    
    for contract in contracts {
        // Step 1: Compile runtime code
        let runtime_bytecode = compile_runtime(&contract.path);
        
        // Step 2: Compile deployment code (which depends on runtime)
        let deploy_bytecode = compile_deploy(&contract.path);
        
        bytecodes.push(ContractBytecode {
            name: contract.name.clone(),
            runtime_bytecode,
            deploy_bytecode,
        });
    }
    
    bytecodes
}

fn compile_runtime(path: &str) -> Vec<u8> {
    // Use your existing compilation logic
    // This is similar to your compile_runtime function
    
    // Run cargo build with appropriate flags
    let status = std::process::Command::new("cargo")
        .arg("+nightly-2025-01-07")
        .arg("build")
        .arg("-r")
        .arg("--lib")
        .arg("-Z")
        .arg("build-std=core,alloc")
        .arg("--target")
        .arg("riscv64imac-unknown-none-elf")
        .arg("--bin")
        .arg("runtime")
        .current_dir(path)
        .status()
        .expect("Failed to execute cargo command");
    
    if !status.success() {
        panic!("Failed to compile runtime for {}", path);
    }
    
    // Read the compiled binary
    let runtime_path = format!(
        "{}/target/riscv64imac-unknown-none-elf/release/runtime",
        path
    );
    
    std::fs::read(runtime_path).expect("Failed to read runtime binary")
}

fn compile_deploy(path: &str) -> Vec<u8> {
    // Similar to compile_runtime, but for deployment code
    // Make sure to include the --features deploy flag
    
    let status = std::process::Command::new("cargo")
        .arg("+nightly-2025-01-07")
        .arg("build")
        .arg("-r")
        .arg("--lib")
        .arg("-Z")
        .arg("build-std=core,alloc")
        .arg("--target")
        .arg("riscv64imac-unknown-none-elf")
        .arg("--bin")
        .arg("deploy")
        .arg("--features")
        .arg("deploy")
        .current_dir(path)
        .status()
        .expect("Failed to execute cargo command");
    
    if !status.success() {
        panic!("Failed to compile deploy binary for {}", path);
    }
    
    // Read the compiled binary
    let deploy_path = format!(
        "{}/target/riscv64imac-unknown-none-elf/release/deploy",
        path
    );
    
    std::fs::read(deploy_path).expect("Failed to read deploy binary")
}

fn generate_bytecode_module(bytecodes: Vec<ContractBytecode>) {
    // Get the project root directory
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR")
        .expect("Failed to get manifest directory");
    
    // Create the generated code directory if it doesn't exist
    let generated_dir = std::path::Path::new(&manifest_dir).join(GENERATED_CODE_PATH);
    std::fs::create_dir_all(&generated_dir)
        .expect("Failed to create generated code directory");
    
    // Create the module content (same as before)
    let mut module = String::from("// Auto-generated bytecode module\n\n");
    
    for bytecode in &bytecodes {
        // Convert bytecode to Rust array literals
        let runtime_bytes = bytecode_to_rust_array(&bytecode.runtime_bytecode);
        let deploy_bytes = bytecode_to_rust_array(&bytecode.deploy_bytecode);
        
        // Add constants to the module
        module.push_str(&format!(
            "pub mod {} {{\n", 
            sanitize_name(&bytecode.name)
        ));
        
        module.push_str(&format!(
            "    pub const RUNTIME_BYTECODE: &[u8] = &[{}];\n", 
            runtime_bytes
        ));
        
        module.push_str(&format!(
            "    pub const DEPLOY_BYTECODE: &[u8] = &[{}];\n", 
            deploy_bytes
        ));
        
        module.push_str("}\n\n");
    }
    
    // Add a registry function
    module.push_str("pub fn get_contract_bytecode(name: &str) -> Option<(&'static [u8], &'static [u8])> {\n");
    module.push_str("    match name {\n");
    
    for bytecode in bytecodes {
        let name = sanitize_name(&bytecode.name);
        module.push_str(&format!(
            "        \"{}\" => Some(({0}::RUNTIME_BYTECODE, {0}::DEPLOY_BYTECODE)),\n",
            name
        ));
    }
    
    module.push_str("        _ => None,\n");
    module.push_str("    }\n");
    module.push_str("}\n");
    
    // Write the module to a file in the deterministic location
    let out_path = generated_dir.join("contract_bytecodes.rs");
    std::fs::write(out_path, module)
        .expect("Failed to write bytecode module");
    
    // Tell Cargo to rerun the build script if the generated file changes
    println!("cargo:rerun-if-changed={}/contract_bytecodes.rs", GENERATED_CODE_PATH);}

fn bytecode_to_rust_array(bytes: &[u8]) -> String {
    bytes.iter()
        .map(|b| format!("0x{:02x},", b))
        .collect::<Vec<_>>()
        .join(" ")
}

fn sanitize_name(name: &str) -> String {
    // Convert to a valid Rust identifier
    name.replace('-', "_").to_lowercase()
}


================================================
File: r55/src/error.rs
================================================
//! R55 crate errors

use core::fmt;

use alloy_primitives::{keccak256, Bytes};
use revm::{
    primitives::{EVMError, ExecutionResult, Log},
    Database, InMemoryDB,
};
use rvemu::exception::Exception;

pub type Result<T> = core::result::Result<T, Error>;

#[derive(Debug)]
pub struct TxResult {
    pub output: Vec<u8>,
    pub logs: Vec<Log>,
    pub gas_used: u64,
    pub status: bool,
}

/// Error encountered on RISC-V execution
#[allow(clippy::enum_variant_names)]
#[derive(Debug, thiserror::Error)]
pub enum Error<DB: Database = InMemoryDB>
where
    DB::Error: std::error::Error + 'static,
{
    /// The exception kind on RISC-V emulator
    RvEmuException(Exception),
    /// EVM error
    EvmError(#[from] EVMError<DB::Error>),
    /// Error returned when a conversion from a slice to an array fails
    TryFromSliceError(#[from] std::array::TryFromSliceError),
    /// Unhandled syscall error
    SyscallError(eth_riscv_syscalls::Error),
    /// Unexpected result of the transaction execution error
    UnexpectedExecResult(ExecutionResult),
}

// Note: this `From` implementation here because `rvemu::exception::Exception`
// doesn't implements std error trait.
impl From<Exception> for Error {
    #[inline]
    fn from(exception: Exception) -> Self {
        Self::RvEmuException(exception)
    }
}

// Note: this `From` implementation here because `eth_riscv_syscalls::Error`
// doesn't implements std error trait.
impl From<eth_riscv_syscalls::Error> for Error {
    #[inline]
    fn from(err: eth_riscv_syscalls::Error) -> Self {
        Self::SyscallError(err)
    }
}

impl<E> From<Error> for EVMError<E> {
    #[inline]
    fn from(err: Error) -> Self {
        EVMError::Custom(err.to_string())
    }
}

impl fmt::Display for TxResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Tx Result:\n> success: {}\n> gas used: {}\n> outcome: {}\n> logs: {:#?}\n",
            self.status,
            self.gas_used,
            revm::primitives::Bytes::from(self.output.clone()),
            self.logs,
        )
    }
}

impl<DB: Database> fmt::Display for Error<DB>
where
    DB::Error: std::error::Error + 'static,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::UnexpectedExecResult(ExecutionResult::Revert { gas_used, output }) => {
                write!(
                    f,
                    "Unexpected result of the transaction execution:\n REVERT:\n > output [hex]: {}\n > output [str]: {}\n > gas used: {}",
                    output,
                    String::from_utf8(output.to_vec()).unwrap_or_default(),
                    gas_used
                )
            }
            Self::RvEmuException(e) => write!(f, "Got RISC-V emulator exception: {:?}", e),
            Self::EvmError(e) => write!(f, "{}", e),
            Self::TryFromSliceError(e) => write!(f, "{}", e),
            Self::SyscallError(e) => write!(f, "Syscall error: {}", e),
            Self::UnexpectedExecResult(other) => write!(
                f,
                "Unexpected result of the transaction execution: {:?}",
                other
            ),
        }
    }
}

impl<DB: Database> Error<DB>
where
    DB::Error: std::error::Error + 'static,
{
    pub fn matches_string_error(&self, err: &'static str) -> bool {
        if let Error::UnexpectedExecResult(ExecutionResult::Revert {
            gas_used: _,
            output,
        }) = &self
        {
            if &Bytes::from(err) != output {
                return false;
            }

            true
        } else {
            false
        }
    }

    pub fn matches_custom_error(&self, err: &'static str) -> bool {
        if let Error::UnexpectedExecResult(ExecutionResult::Revert {
            gas_used: _,
            output,
        }) = &self
        {
            if keccak256(err)[..4].to_vec() != output[..4] {
                return false;
            }

            true
        } else {
            false
        }
    }

    pub fn matches_custom_error_with_args(&self, err: &'static str, args: Vec<u8>) -> bool {
        if let Error::UnexpectedExecResult(ExecutionResult::Revert {
            gas_used: _,
            output,
        }) = &self
        {
            let err = Bytes::from(keccak256(err)[..4].to_vec());
            if err != output[..4] {
                return false;
            }

            if !args.is_empty() && output[4..].to_vec() != args {
                return false;
            }

            true
        } else {
            false
        }
    }
}


================================================
File: r55/src/exec.rs
================================================
use alloy_core::primitives::{Keccak256, U32};
use core::cell::RefCell;
use eth_riscv_interpreter::setup_from_elf;
use eth_riscv_syscalls::Syscall;
use revm::{
    handler::register::EvmHandler,
    interpreter::{
        CreateInputs, CreateScheme, CallInputs, CallScheme, CallValue, Host, InstructionResult, Interpreter, InterpreterAction,
        InterpreterResult, SharedMemory,
    },
    primitives::{address, Address, Bytes, ExecutionResult, Log, Output, TransactTo, B256, U256},
    Database, Evm, Frame, FrameOrResult, InMemoryDB,
};
use rvemu::{emulator::Emulator, exception::Exception};
use std::{collections::BTreeMap, rc::Rc, sync::Arc};
use tracing::{debug, info, trace, warn};

use super::error::{Error, Result, TxResult};
use super::gas;
use super::syscall_gas;

const R5_REST_OF_RAM_INIT: u64 = 0x80300000; // Defined at `r5-rust-rt.x`

pub fn deploy_contract(
    db: &mut InMemoryDB,
    bytecode: Bytes,
    encoded_args: Option<Vec<u8>>,
) -> Result<Address> {
    let init_code = if Some(&0xff) == bytecode.first() {
        // Craft R55 initcode: [0xFF][codesize][bytecode][constructor_args]
        let codesize = U32::from(bytecode.len());
        debug!("CODESIZE: {}", codesize);

        let mut init_code = Vec::new();
        init_code.push(0xff);
        init_code.extend_from_slice(&Bytes::from(codesize.to_be_bytes_vec()));
        init_code.extend_from_slice(&bytecode);
        if let Some(args) = encoded_args {
            debug!("ENCODED_ARGS: {:#?}", Bytes::from(args.clone()));
            init_code.extend_from_slice(&args);
        }
        debug!("INITCODE SIZE: {}", init_code.len());
        Bytes::from(init_code)
    } else {
        // do not modify bytecode for EVM contracts
        bytecode
    };

    // Run CREATE tx
    let mut evm = Evm::builder()
        .with_db(db)
        .modify_tx_env(|tx| {
            tx.caller = address!("000000000000000000000000000000000000000A");
            tx.transact_to = TransactTo::Create;
            tx.data = init_code;
            tx.value = U256::from(0);
        })
        .append_handler_register(handle_register)
        .build();
    evm.cfg_mut().limit_contract_code_size = Some(usize::MAX);

    let result = evm.transact_commit()?;

    match result {
        ExecutionResult::Success {
            output: Output::Create(_value, Some(addr)),
            logs,
            ..
        } => {
            info!(
                "NEW DEPLOYMENT:\n> contract address: {:?}{}",
                addr,
                if logs.is_empty() {
                    ""
                } else {
                    "\n> logs: {:#?}\n"
                }
            );
            Ok(addr)
        }
        result => Err(Error::UnexpectedExecResult(result)),
    }
}

pub fn run_tx(
    db: &mut InMemoryDB,
    addr: &Address,
    calldata: Vec<u8>,
    caller: &Address,
) -> Result<TxResult> {
    let mut evm = Evm::builder()
        .with_db(db)
        .modify_tx_env(|tx| {
            tx.caller = *caller;
            tx.transact_to = TransactTo::Call(*addr);
            tx.data = calldata.into();
            tx.value = U256::from(0);
            tx.gas_price = U256::from(42);
            tx.gas_limit = 100_000;
        })
        .append_handler_register(handle_register)
        .build();

    let result = evm.transact_commit()?;

    match result {
        ExecutionResult::Success {
            reason: _,
            gas_used,
            gas_refunded: _,
            logs,
            output: Output::Call(value),
            ..
        } => {
            debug!("Tx result: {:?}", value);
            Ok(TxResult {
                output: value.into(),
                logs,
                gas_used,
                status: true,
            })
        }
        result => Err(Error::UnexpectedExecResult(result)),
    }
}

#[derive(Debug)]
struct RVEmu {
    emu: Emulator,
}

fn riscv_context(frame: &Frame) -> Option<RVEmu> {
    let interpreter = frame.interpreter();

    let Some((0xFF, bytecode)) = interpreter.bytecode.split_first() else {
        warn!("NOT RISCV CONTRACT!");
        return None;
    };

    let (code, calldata) = if frame.is_create() {
        let (code_size, init_code) = bytecode.split_at(4);
        let Some((0xFF, bytecode)) = init_code.split_first() else {
            warn!("NOT RISCV CONTRACT!");
            return None;
        };
        let code_size = U32::from_be_slice(code_size).to::<usize>() - 1; // deduct control byte `0xFF`
        let end_of_args = init_code.len() - 34; // deduct control byte + ignore empty (32 byte) word appended by revm

        (&bytecode[..code_size], &bytecode[code_size..end_of_args])
    } else if frame.is_call() {
        (bytecode, interpreter.contract.input.as_ref())
    } else {
        todo!("Support EOF")
    };

    match setup_from_elf(code, calldata) {
        Ok(emu) => Some(RVEmu { emu }),
        Err(err) => {
            warn!("Failed to setup from ELF: {err}");
            None
        }
    }
}

pub fn handle_register<EXT, DB: Database>(handler: &mut EvmHandler<'_, EXT, DB>) {
    trace!("HANDLE REGISTER");
    let call_stack = Rc::<RefCell<Vec<_>>>::new(RefCell::new(Vec::new()));

    // create a riscv context on call frame.
    let call_stack_inner = call_stack.clone();
    let old_handle = handler.execution.call.clone();
    handler.execution.call = Arc::new(move |ctx, inputs| {
        let result = old_handle(ctx, inputs);
        if let Ok(FrameOrResult::Frame(frame)) = &result {
            trace!("Creating new CALL frame");
            call_stack_inner.borrow_mut().push(riscv_context(frame));
        }
        result
    });

    // create a riscv context on create frame.
    let call_stack_inner = call_stack.clone();
    let old_handle = handler.execution.create.clone();
    handler.execution.create = Arc::new(move |ctx, inputs| {
        let result = old_handle(ctx, inputs);
        if let Ok(FrameOrResult::Frame(frame)) = &result {
            trace!("Creating new CREATE frame");
            call_stack_inner.borrow_mut().push(riscv_context(frame));
        }
        result
    });

    // execute riscv context or old logic.
    let old_handle = handler.execution.execute_frame.clone();
    handler.execution.execute_frame = Arc::new(move |frame, memory, instraction_table, ctx| {
        let depth = call_stack.borrow().len() - 1;

        // use last frame as stack is LIFO
        let result = if let Some(Some(riscv_context)) = call_stack.borrow_mut().last_mut() {
            debug!(
                "=== [FRAME-{}] Contract: {} ============-",
                depth,
                frame.interpreter().contract.target_address,
            );
            execute_riscv(riscv_context, frame.interpreter_mut(), memory, ctx)?
        } else {
            debug!("=== [OLD Handler] ==================--");
            old_handle(frame, memory, instraction_table, ctx)?
        };

        // if action is return, pop the stack.
        if result.is_return() {
            call_stack.borrow_mut().pop();
        }

        debug!("=== [Frame-{}] {:#?}", depth, frame.interpreter().gas);
        Ok(result)
    });
}

fn execute_riscv(
    rvemu: &mut RVEmu,
    interpreter: &mut Interpreter,
    _shared_memory: &mut SharedMemory,
    host: &mut dyn Host,
) -> Result<InterpreterAction> {
    trace!(
        "{} RISC-V execution:  PC: {:#x}",
        if rvemu.emu.cpu.pc == R5_REST_OF_RAM_INIT {
            "Starting"
        } else {
            "Resuming"
        },
        rvemu.emu.cpu.pc,
    );

    let emu = &mut rvemu.emu;
    emu.cpu.is_count = true;

    let return_revert = |interpreter: &mut Interpreter, gas_used: u64| {
        let _ = interpreter.gas.record_cost(gas_used);
        Ok(InterpreterAction::Return {
            result: InterpreterResult {
                result: InstructionResult::Revert,
                // return empty bytecode
                output: Bytes::new(),
                gas: interpreter.gas,
            },
        })
    };

    // Run emulator and capture ecalls
    loop {
        let run_result = emu.start();
        match run_result {
            Err(Exception::EnvironmentCallFromMMode) => {
                let t0: u64 = emu.cpu.xregs.read(5);

                let Ok(syscall) = Syscall::try_from(t0 as u8) else {
                    warn!("Unhandled syscall: {:?}", t0);
                    return return_revert(interpreter, interpreter.gas.spent());
                };
                debug!("[Syscall::{} - {:#04x}]", syscall, t0);

                match syscall {
                    Syscall::Return => {
                        let ret_offset: u64 = emu.cpu.xregs.read(10);
                        let ret_size: u64 = emu.cpu.xregs.read(11);

                        let r55_gas = r55_gas_used(&emu.cpu.inst_counter);
                        debug!("> Total R55 gas: {}", r55_gas);

                        // RETURN logs the gas of the whole risc-v instruction set
                        syscall_gas!(interpreter, r55_gas);

                        let data_bytes = dram_slice(emu, ret_offset, ret_size)?;

                        return Ok(InterpreterAction::Return {
                            result: InterpreterResult {
                                result: InstructionResult::Return,
                                output: data_bytes.to_vec().into(),
                                gas: interpreter.gas, // FIXME: gas is not correct
                            },
                        });
                    }
                    Syscall::SLoad => {
                        let key1: u64 = emu.cpu.xregs.read(10);
                        let key2: u64 = emu.cpu.xregs.read(11);
                        let key3: u64 = emu.cpu.xregs.read(12);
                        let key4: u64 = emu.cpu.xregs.read(13);
                        let key = U256::from_limbs([key1, key2, key3, key4]);
                        debug!(
                            "> SLOAD ({}) - Key: {:#02x}",
                            interpreter.contract.target_address, key
                        );
                        match host.sload(interpreter.contract.target_address, key) {
                            Some(state_load) => {
                                debug!(
                                    "> SLOAD ({}) - Value: {}",
                                    interpreter.contract.target_address, state_load.data
                                );
                                let limbs = state_load.data.as_limbs();
                                emu.cpu.xregs.write(10, limbs[0]);
                                emu.cpu.xregs.write(11, limbs[1]);
                                emu.cpu.xregs.write(12, limbs[2]);
                                emu.cpu.xregs.write(13, limbs[3]);
                                syscall_gas!(
                                    interpreter,
                                    if state_load.is_cold {
                                        gas::SLOAD_COLD
                                    } else {
                                        gas::SLOAD_WARM
                                    }
                                );
                            }
                            _ => {
                                return return_revert(interpreter, interpreter.gas.spent());
                            }
                        }
                    }
                    Syscall::SStore => {
                        let key1: u64 = emu.cpu.xregs.read(10);
                        let key2: u64 = emu.cpu.xregs.read(11);
                        let key3: u64 = emu.cpu.xregs.read(12);
                        let key4: u64 = emu.cpu.xregs.read(13);
                        let key = U256::from_limbs([key1, key2, key3, key4]);
                        debug!(
                            "> SSTORE ({}) - Key: {}",
                            interpreter.contract.target_address, key
                        );

                        let val1: u64 = emu.cpu.xregs.read(14);
                        let val2: u64 = emu.cpu.xregs.read(15);
                        let val3: u64 = emu.cpu.xregs.read(16);
                        let val4: u64 = emu.cpu.xregs.read(17);
                        let value = U256::from_limbs([val1, val2, val3, val4]);
                        debug!(
                            "> SSTORE ({}) - Value: {}",
                            interpreter.contract.target_address, value
                        );

                        let result = host.sstore(interpreter.contract.target_address, key, value);
                        if let Some(result) = result {
                            syscall_gas!(
                                interpreter,
                                if result.is_cold {
                                    gas::SSTORE_COLD
                                } else {
                                    gas::SSTORE_WARM
                                }
                            );
                        }
                    }
                    Syscall::ReturnDataSize => {
                        let size = interpreter.return_data_buffer.len();
                        debug!("> RETURNDATASIZE: {}", size);
                        emu.cpu.xregs.write(10, size as u64);
                    }
                    Syscall::ReturnDataCopy => {
                        let dest_offset = emu.cpu.xregs.read(10);
                        let offset = emu.cpu.xregs.read(11) as usize;
                        let size = emu.cpu.xregs.read(12) as usize;
                        let data = &interpreter.return_data_buffer.as_ref()[offset..offset + size];
                        debug!(
                            "> RETURNDATACOPY [memory_offset: {}, offset: {}, size: {}]\n{}",
                            dest_offset,
                            offset,
                            size,
                            Bytes::from(data.to_vec())
                        );

                        // write return data to memory
                        let return_memory = emu
                            .cpu
                            .bus
                            .get_dram_slice(dest_offset..(dest_offset + size as u64))?;
                        return_memory.copy_from_slice(data);
                    }
                    Syscall::Call => return execute_call(emu, interpreter, host, false),
                    Syscall::StaticCall => return execute_call(emu, interpreter, host, true),
                    Syscall::Create => return execute_create(emu, interpreter, host),
                    Syscall::Revert => {
                        let ret_offset: u64 = emu.cpu.xregs.read(10);
                        let ret_size: u64 = emu.cpu.xregs.read(11);
                        let data_bytes: Vec<u8> = dram_slice(emu, ret_offset, ret_size)?.into();
                        debug!("REVERT > offset: {:#04x}, size: {}", ret_offset, ret_size);

                        return Ok(InterpreterAction::Return {
                            result: InterpreterResult {
                                result: InstructionResult::Revert,
                                output: Bytes::from(data_bytes),
                                gas: interpreter.gas, // FIXME: gas is not correct
                            },
                        });
                    }
                    Syscall::Caller => {
                        let caller = interpreter.contract.caller;
                        // Break address into 3 u64s and write to registers
                        let caller_bytes = caller.as_slice();
                        let first_u64 = u64::from_be_bytes(caller_bytes[0..8].try_into()?);
                        emu.cpu.xregs.write(10, first_u64);
                        let second_u64 = u64::from_be_bytes(caller_bytes[8..16].try_into()?);
                        emu.cpu.xregs.write(11, second_u64);
                        let mut padded_bytes = [0u8; 8];
                        padded_bytes[..4].copy_from_slice(&caller_bytes[16..20]);
                        let third_u64 = u64::from_be_bytes(padded_bytes);
                        emu.cpu.xregs.write(12, third_u64);
                    }
                    Syscall::Keccak256 => {
                        let ret_offset: u64 = emu.cpu.xregs.read(10);
                        let ret_size: u64 = emu.cpu.xregs.read(11);
                        let data_bytes = dram_slice(emu, ret_offset, ret_size)?;

                        let mut hasher = Keccak256::new();
                        hasher.update(data_bytes);
                        let hash: U256 = hasher.finalize().into();
                        debug!("KECCAK256: {:?}", hash);

                        let limbs = hash.as_limbs();
                        emu.cpu.xregs.write(10, limbs[0]);
                        emu.cpu.xregs.write(11, limbs[1]);
                        emu.cpu.xregs.write(12, limbs[2]);
                        emu.cpu.xregs.write(13, limbs[3]);
                    }
                    Syscall::CallValue => {
                        let value = interpreter.contract.call_value;
                        let limbs = value.into_limbs();
                        emu.cpu.xregs.write(10, limbs[0]);
                        emu.cpu.xregs.write(11, limbs[1]);
                        emu.cpu.xregs.write(12, limbs[2]);
                        emu.cpu.xregs.write(13, limbs[3]);
                    }
                    Syscall::BaseFee => {
                        let value = host.env().block.basefee;
                        let limbs = value.as_limbs();
                        emu.cpu.xregs.write(10, limbs[0]);
                        emu.cpu.xregs.write(11, limbs[1]);
                        emu.cpu.xregs.write(12, limbs[2]);
                        emu.cpu.xregs.write(13, limbs[3]);
                    }
                    Syscall::ChainId => {
                        let value = host.env().cfg.chain_id;
                        emu.cpu.xregs.write(10, value);
                    }
                    Syscall::GasLimit => {
                        let limit = host.env().block.gas_limit;
                        let limbs = limit.as_limbs();
                        emu.cpu.xregs.write(10, limbs[0]);
                        emu.cpu.xregs.write(11, limbs[1]);
                        emu.cpu.xregs.write(12, limbs[2]);
                        emu.cpu.xregs.write(13, limbs[3]);
                    }
                    Syscall::Number => {
                        let number = host.env().block.number;
                        let limbs = number.as_limbs();
                        emu.cpu.xregs.write(10, limbs[0]);
                        emu.cpu.xregs.write(11, limbs[1]);
                        emu.cpu.xregs.write(12, limbs[2]);
                        emu.cpu.xregs.write(13, limbs[3]);
                    }
                    Syscall::Timestamp => {
                        let timestamp = host.env().block.timestamp;
                        let limbs = timestamp.as_limbs();
                        emu.cpu.xregs.write(10, limbs[0]);
                        emu.cpu.xregs.write(11, limbs[1]);
                        emu.cpu.xregs.write(12, limbs[2]);
                        emu.cpu.xregs.write(13, limbs[3]);
                    }
                    Syscall::GasPrice => {
                        let value = host.env().tx.gas_price;
                        let limbs = value.as_limbs();
                        emu.cpu.xregs.write(10, limbs[0]);
                        emu.cpu.xregs.write(11, limbs[1]);
                        emu.cpu.xregs.write(12, limbs[2]);
                        emu.cpu.xregs.write(13, limbs[3]);
                    }
                    Syscall::Origin => {
                        // Syscall::Origin
                        let origin = host.env().tx.caller;
                        // Break address into 3 u64s and write to registers
                        let origin_bytes = origin.as_slice();

                        let first_u64 = u64::from_be_bytes(origin_bytes[0..8].try_into().unwrap());
                        emu.cpu.xregs.write(10, first_u64);

                        let second_u64 =
                            u64::from_be_bytes(origin_bytes[8..16].try_into().unwrap());
                        emu.cpu.xregs.write(11, second_u64);

                        let mut padded_bytes = [0u8; 8];
                        padded_bytes[..4].copy_from_slice(&origin_bytes[16..20]);
                        let third_u64 = u64::from_be_bytes(padded_bytes);
                        emu.cpu.xregs.write(12, third_u64);
                    }
                    Syscall::Log => {
                        let data_ptr: u64 = emu.cpu.xregs.read(10);
                        let data_size: u64 = emu.cpu.xregs.read(11);
                        let topics_ptr: u64 = emu.cpu.xregs.read(12);
                        let topics_size: u64 = emu.cpu.xregs.read(13);

                        // Read data
                        let data = if data_size == 0 {
                            Vec::new()
                        } else {
                            let data_slice = emu
                                .cpu
                                .bus
                                .get_dram_slice(data_ptr..(data_ptr + data_size))
                                .unwrap_or(&mut []);
                            data_slice.to_vec()
                        };
                        trace!("> LOGS [DATA]: {:?}", Bytes::from(data.clone()));

                        // Read topics
                        let topics_start = topics_ptr;
                        let topics_end = topics_ptr + topics_size * 32;
                        let topics_slice = emu
                            .cpu
                            .bus
                            .get_dram_slice(topics_start..topics_end)
                            .unwrap_or(&mut []);
                        let topics = topics_slice
                            .chunks(32)
                            .map(B256::from_slice)
                            .collect::<Vec<B256>>();
                        trace!("> LOGS [TOPICS]: {:#?}", &topics);

                        host.log(Log::new_unchecked(
                            interpreter.contract.target_address,
                            topics,
                            data.into(),
                        ));
                    }
                }
            }
            Ok(_) => {
                trace!("Successful instruction at PC: {:#x}", emu.cpu.pc);
                continue;
            }
            Err(e) => {
                debug!("Execution error: {:#?}", e);
                syscall_gas!(interpreter, r55_gas_used(&emu.cpu.inst_counter));
                return return_revert(interpreter, interpreter.gas.spent());
            }
        }
    }
}

fn execute_call(
    emu: &mut Emulator,
    interpreter: &mut Interpreter,
    host: &mut dyn Host,
    is_static: bool,
) -> Result<InterpreterAction> {
    let a0: u64 = emu.cpu.xregs.read(10);
    let a1: u64 = emu.cpu.xregs.read(11);
    let a2: u64 = emu.cpu.xregs.read(12);
    let addr = Address::from_word(U256::from_limbs([a0, a1, a2, 0]).into());
    let value: u64 = emu.cpu.xregs.read(13);

    // Get calldata
    let args_offset: u64 = emu.cpu.xregs.read(14);
    let args_size: u64 = emu.cpu.xregs.read(15);
    let calldata: Bytes = emu
        .cpu
        .bus
        .get_dram_slice(args_offset..(args_offset + args_size))
        .unwrap_or(&mut [])
        .to_vec()
        .into();

    // Calculate gas cost of the call
    // TODO: check correctness (tried using evm.codes as ref but i'm no gas wizard)
    // TODO: unsure whether memory expansion cost is missing (should be captured in the risc-v costs)
    let (empty_account_cost, addr_access_cost) = match host.load_account_delegated(addr) {
        Some(account) => {
            if account.is_cold {
                (0, gas::CALL_NEW_ACCOUNT)
            } else {
                (0, gas::CALL_BASE)
            }
        }
        None => (gas::CALL_EMPTY_ACCOUNT, gas::CALL_NEW_ACCOUNT),
    };
    let value_cost = if value != 0 { gas::CALL_VALUE } else { 0 };
    let call_gas_cost = empty_account_cost + addr_access_cost + value_cost;
    syscall_gas!(interpreter, call_gas_cost);

    // proactively spend gas limit as the remaining will be refunded (otherwise it underflows)
    let call_gas_limit = interpreter.gas.remaining();
    syscall_gas!(interpreter, call_gas_limit);

    debug!("> {}Call context:", if is_static { "Static" } else { "" });
    debug!("  - Caller: {}", interpreter.contract.target_address);
    debug!("  - Target Address: {}", addr);
    debug!("  - Value: {}", value);
    debug!("  - Calldata: {:?}", calldata);
    Ok(InterpreterAction::Call {
        inputs: Box::new(CallInputs {
            input: calldata,
            gas_limit: call_gas_limit,
            target_address: addr,
            bytecode_address: addr,
            caller: interpreter.contract.target_address,
            value: CallValue::Transfer(U256::from(value)),
            scheme: CallScheme::Call,
            is_static,
            is_eof: false,
            return_memory_offset: 0..0, // handled with RETURNDATACOPY
        }),
    })
}

fn execute_create(
    emu: &mut Emulator,
    interpreter: &mut Interpreter,
    _host: &mut dyn Host,
) -> Result<InterpreterAction> {
    let value: u64 = emu.cpu.xregs.read(10);

    // Get initcode
    let args_offset: u64 = emu.cpu.xregs.read(11);
    let args_size: u64 = emu.cpu.xregs.read(12);
    let init_code: Bytes = emu
        .cpu
        .bus
        .get_dram_slice(args_offset..(args_offset + args_size))
        .unwrap_or(&mut [])
        .to_vec()
        .into();

    // TODO: calc gas cost and call_gas_limit
    let call_gas_limit = u64::MAX;

    debug!("> Create context:");
    debug!("  - Caller: {}", interpreter.contract.target_address);
    debug!("  - Value: {}", value);
    debug!("  - Initcode: {:?}", init_code);
    Ok(InterpreterAction::Create {
        inputs: Box::new(CreateInputs {
            init_code,
            gas_limit: call_gas_limit,
            caller: interpreter.contract.target_address,
            value: U256::from(value),
            scheme: CreateScheme::Create
        }),
    })
}

/// Returns RISC-V DRAM slice in a given size range, starts with a given offset
fn dram_slice(emu: &mut Emulator, ret_offset: u64, ret_size: u64) -> Result<&mut [u8]> {
    if ret_size != 0 {
        Ok(emu
            .cpu
            .bus
            .get_dram_slice(ret_offset..(ret_offset + ret_size))?)
    } else {
        Ok(&mut [])
    }
}

fn r55_gas_used(inst_count: &BTreeMap<String, u64>) -> u64 {
    let total_cost = inst_count
        .iter()
        .map(|(inst_name, count)|
            // Gas cost = number of instructions * cycles per instruction
            match inst_name.as_str() {
                // Gas map to approximate cost of each instruction
                // References:
                // http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/
                // https://www.evm.codes/?fork=cancun#54
                // Division and remainder
                s if s.starts_with("div") || s.starts_with("rem") => count * 25,
                // Multiplications
                s if s.starts_with("mul") => count * 5,
                // Loads
                "lb" | "lh" | "lw" | "ld" | "lbu" | "lhu" | "lwu" => count * 3, // Cost analagous to `MLOAD`
                // Stores
                "sb" | "sh" | "sw" | "sd" | "sc.w" | "sc.d" => count * 3, // Cost analagous to `MSTORE`
                // Branching
                "beq" | "bne" | "blt" | "bge" | "bltu" | "bgeu" | "jal" | "jalr" => count * 3,
                _ => *count, // All other instructions including `add` and `sub`
        })
        .sum::<u64>();

    // This is the minimum 'gas used' to ABI decode 'empty' calldata into Rust type arguments. Real calldata will take more gas.
    // Internalising this would focus gas metering more on the function logic
    let abi_decode_cost = 9_175_538;

    total_cost - abi_decode_cost
}


================================================
File: r55/src/gas.rs
================================================
// Standard EVM operation costs
pub const SLOAD_COLD: u64 = 2100;
pub const SLOAD_WARM: u64 = 100;
pub const SSTORE_COLD: u64 = 2200;
pub const SSTORE_WARM: u64 = 100;

// Call-related costs
pub const CALL_EMPTY_ACCOUNT: u64 = 25000;
pub const CALL_NEW_ACCOUNT: u64 = 2600;
pub const CALL_VALUE: u64 = 9000;
pub const CALL_BASE: u64 = 100;

// Macro to handle gas accounting for syscalls.
// Returns OutOfGas InterpreterResult if gas limit is exceeded.
#[macro_export]
macro_rules! syscall_gas {
    ($interpreter:expr, $gas_cost:expr $(,)?) => {{
        let gas_cost = $gas_cost;

        trace!("> About to record gas costs:");
        trace!("  - Gas limit: {}", $interpreter.gas.limit());
        trace!("  - Gas prev spent: {}", $interpreter.gas.spent());
        trace!("  - Operation cost: {}", gas_cost);

        if !$interpreter.gas.record_cost(gas_cost) {
            eprintln!("OUT OF GAS");
            return Ok(InterpreterAction::Return {
                result: InterpreterResult {
                    result: InstructionResult::OutOfGas,
                    output: Bytes::new(),
                    gas: $interpreter.gas,
                },
            });
        }

        trace!("> Gas recorded successfully:");
        trace!("  - Gas remaining: {}", $interpreter.gas.remaining());
        trace!("  - Gas spent: {}", $interpreter.gas.spent());
    }};
}


================================================
File: r55/src/lib.rs
================================================
pub mod exec;

mod error;
mod gas;

pub mod test_utils;

use alloy_primitives::Bytes;
use std::fs::File;
use std::io::Read;
use std::process::Command;
use tracing::{error, info};

// Include the generated bytecode module
pub mod bytecodes {
    include!("generated/contract_bytecodes.rs");
}

// Provide a function to get bytecode by contract name
pub fn get_contract_bytecode(name: &str) -> Option<(&'static [u8], &'static [u8])> {
    bytecodes::get_contract_bytecode(name)
}

fn compile_runtime(path: &str) -> eyre::Result<Vec<u8>> {
    info!("Compiling runtime: {}", path);
    let status = Command::new("cargo")
        .arg("+nightly-2025-01-07")
        .arg("build")
        .arg("-r")
        .arg("--lib")
        .arg("-Z")
        .arg("build-std=core,alloc")
        .arg("--target")
        .arg("riscv64imac-unknown-none-elf")
        .arg("--bin")
        .arg("runtime")
        .current_dir(path)
        .status()
        .expect("Failed to execute cargo command");

    if !status.success() {
        error!("Cargo command failed with status: {}", status);
        std::process::exit(1);
    } else {
        info!("Cargo command completed successfully");
    }

    let path = format!(
        "{}/target/riscv64imac-unknown-none-elf/release/runtime",
        path
    );
    let mut file = match File::open(path) {
        Ok(file) => file,
        Err(e) => {
            eyre::bail!("Failed to open file: {}", e);
        }
    };

    // Read the file contents into a vector.
    let mut bytecode = Vec::new();
    if let Err(e) = file.read_to_end(&mut bytecode) {
        eyre::bail!("Failed to read file: {}", e);
    }

    Ok(bytecode)
}

pub fn compile_deploy(path: &str) -> eyre::Result<Vec<u8>> {
    compile_runtime(path)?;
    info!("Compiling deploy: {}", path);
    let status = Command::new("cargo")
        .arg("+nightly-2025-01-07")
        .arg("build")
        .arg("-r")
        .arg("--lib")
        .arg("-Z")
        .arg("build-std=core,alloc")
        .arg("--target")
        .arg("riscv64imac-unknown-none-elf")
        .arg("--bin")
        .arg("deploy")
        .arg("--features")
        .arg("deploy")
        .current_dir(path)
        .status()
        .expect("Failed to execute cargo command");

    if !status.success() {
        error!("Cargo command failed with status: {}", status);
        std::process::exit(1);
    } else {
        info!("Cargo command completed successfully");
    }

    let path = format!(
        "{}/target/riscv64imac-unknown-none-elf/release/deploy",
        path
    );
    let mut file = match File::open(path) {
        Ok(file) => file,
        Err(e) => {
            eyre::bail!("Failed to open file: {}", e);
        }
    };

    // Read the file contents into a vector.
    let mut bytecode = Vec::new();
    if let Err(e) = file.read_to_end(&mut bytecode) {
        eyre::bail!("Failed to read file: {}", e);
    }

    Ok(bytecode)
}

pub fn compile_with_prefix<F>(compile_fn: F, path: &str) -> eyre::Result<Bytes>
where
    F: FnOnce(&str) -> eyre::Result<Vec<u8>>,
{
    let bytecode = compile_fn(path)?;
    let mut prefixed_bytecode = vec![0xff]; // Add the 0xff prefix
    prefixed_bytecode.extend_from_slice(&bytecode);
    Ok(Bytes::from(prefixed_bytecode))
}

#[cfg(test)]
mod tests {
    use crate::exec::{deploy_contract, run_tx};
    use crate::{compile_deploy, compile_with_prefix, test_utils::*};

    use alloy_core::hex::{self, ToHexExt};
    use alloy_primitives::B256;
    use alloy_sol_types::SolValue;

    const ERC20_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../examples/erc20");
    const ERC20X_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../examples/erc20x");

    fn setup_erc20(owner: Address) -> (InMemoryDB, Address) {
        initialize_logger();
        let mut db = InMemoryDB::default();

        // Fund user accounts with some ETH
        for user in [ALICE, BOB, CAROL] {
            add_balance_to_db(&mut db, user, 1e18 as u64);
        }

        // Deploy contract
        let constructor = owner.abi_encode();
        let bytecode = compile_with_prefix(compile_deploy, ERC20_PATH).unwrap();
        let erc20 = deploy_contract(&mut db, bytecode, Some(constructor)).unwrap();

        (db, erc20)
    }

    fn setup_erc20x(db: &mut InMemoryDB) -> Address {
        // Deploy contract
        let bytecode = compile_with_prefix(compile_deploy, ERC20X_PATH).unwrap();
        deploy_contract(db, bytecode, None).unwrap()
    }

    #[test]
    fn test_runtime() {
        let (mut db, erc20) = setup_erc20(ALICE);

        // Define fn selectors
        let selector_owner = get_selector_from_sig("owner()");
        let selector_total_supply = get_selector_from_sig("total_supply()");
        let selector_balance = get_selector_from_sig("balance_of(address)");
        let selector_mint = get_selector_from_sig("mint(address,uint256)");
        let selector_transfer = get_selector_from_sig("transfer(address,uint256)");
        let selector_approve = get_selector_from_sig("approve(address,uint256)");
        let selector_allowance = get_selector_from_sig("allowance(address,address)");

        // Check that Alice is the contract owner
        let owner_result = run_tx(
            &mut db,
            &erc20,
            get_calldata(selector_owner, vec![]),
            &ALICE,
        )
        .expect("Error executing tx")
        .output;

        assert_eq!(
            B256::from_slice(owner_result.as_slice()),
            ALICE.into_word(),
            "Incorrect owner"
        );

        // Mint 42 tokens to Alice
        let value_mint = U256::from(42e18);
        let calldata_mint = get_calldata(selector_mint, (ALICE, value_mint).abi_encode());
        let mint_result = run_tx(&mut db, &erc20, calldata_mint, &ALICE).unwrap();

        assert!(mint_result.status, "Mint transaction failed");

        // Check total supply
        let total_supply_result = run_tx(
            &mut db,
            &erc20,
            get_calldata(selector_total_supply, vec![]),
            &ALICE,
        )
        .expect("Error executing tx")
        .output;

        assert_eq!(
            U256::from_be_bytes::<32>(total_supply_result.as_slice().try_into().unwrap()),
            value_mint,
            "Incorrect total supply"
        );

        // Check Alice's balance
        let calldata_alice_balance = get_calldata(selector_balance, ALICE.abi_encode());
        let alice_balance_result = run_tx(&mut db, &erc20, calldata_alice_balance.clone(), &ALICE)
            .expect("Error executing tx")
            .output;

        assert_eq!(
            U256::from_be_bytes::<32>(alice_balance_result.as_slice().try_into().unwrap()),
            value_mint,
            "Incorrect balance"
        );

        // Transfer 21 tokens from Alice to Bob
        let value_transfer = U256::from(21e18);
        let calldata_transfer = get_calldata(selector_transfer, (BOB, value_transfer).abi_encode());
        let transfer_result = run_tx(&mut db, &erc20, calldata_transfer.clone(), &ALICE).unwrap();
        assert!(transfer_result.status, "Transfer transaction failed");

        // Check Alice's balance
        let alice_balance_result = run_tx(&mut db, &erc20, calldata_alice_balance.clone(), &ALICE)
            .expect("Error executing tx")
            .output;

        assert_eq!(
            U256::from_be_bytes::<32>(alice_balance_result.as_slice().try_into().unwrap()),
            value_mint - value_transfer,
            "Incorrect balance"
        );

        // Check Bob's balance
        let calldata_bob_balance = get_calldata(selector_balance, BOB.abi_encode());
        let bob_balance_result = run_tx(&mut db, &erc20, calldata_bob_balance.clone(), &ALICE)
            .expect("Error executing tx")
            .output;

        assert_eq!(
            U256::from_be_bytes::<32>(bob_balance_result.as_slice().try_into().unwrap()),
            value_transfer,
            "Incorrect balance"
        );

        // Approve Carol to spend 10 tokens from Alice
        let value_approve = U256::from(10e18);
        let calldata_approve = get_calldata(selector_approve, (CAROL, value_approve).abi_encode());
        let approve_result = run_tx(&mut db, &erc20, calldata_approve.clone(), &ALICE).unwrap();
        assert!(approve_result.status, "Approve transaction failed");

        // Check Carol's allowance
        let calldata_allowance = get_calldata(selector_allowance, (ALICE, CAROL).abi_encode());
        let carol_allowance_result = run_tx(&mut db, &erc20, calldata_allowance.clone(), &ALICE)
            .expect("Error executing tx")
            .output;

        assert_eq!(
            U256::from_be_bytes::<32>(carol_allowance_result.as_slice().try_into().unwrap()),
            value_approve,
            "Incorrect balance"
        );
    }

    #[test]
    fn test_transfer_logs() {
        let (mut db, erc20) = setup_erc20(ALICE);

        // Mint tokens to Alice
        let selector_mint = get_selector_from_sig("mint(address,uint256)");
        let calldata_mint = get_calldata(selector_mint, (ALICE, 100u64).abi_encode());

        let mint_result = run_tx(&mut db, &erc20, calldata_mint, &ALICE).unwrap();
        assert!(mint_result.status, "Mint transaction failed");

        // Transfer tokens from Alice to Bob
        let selector_transfer = get_selector_from_sig("transfer(address,uint256)");
        let calldata_transfer = get_calldata(selector_transfer, (BOB, 50u64).abi_encode());

        let transfer_result = run_tx(&mut db, &erc20, calldata_transfer, &ALICE).unwrap();

        // Assert the transfer log
        assert!(
            !transfer_result.logs.is_empty(),
            "No logs found in transfer transaction"
        );
        let log = &transfer_result.logs[0];
        let topics = log.data.topics();

        // Expected event hash for Transfer event
        let expected_event_hash = keccak256("Transfer(address,address,uint256)");
        assert_eq!(
            hex::encode(topics[0]),
            hex::encode(expected_event_hash),
            "Incorrect event hash"
        );

        // Assert "from" address in log
        assert_eq!(
            hex::encode(&topics[1][12..]),
            ALICE.encode_hex(),
            "Incorrect 'from' address in transfer log"
        );

        // Assert "to" address in log
        assert_eq!(
            hex::encode(&topics[2][12..]),
            BOB.encode_hex(),
            "Incorrect 'to' address in transfer log"
        );

        // Assert transfer amount
        let amount = U256::from_be_slice(log.data.data[..32].try_into().unwrap());
        assert_eq!(
            amount,
            U256::from(50),
            "Incorrect transfer amount in transfer log"
        );
    }

    #[test]
    fn test_storage_layout() {
        let (mut db, erc20) = setup_erc20(ALICE);

        // Mint tokens to Alice
        let mint_alice = U256::from(10e18);
        let selector_mint = get_selector_from_sig("mint(address,uint256)");
        let calldata_mint = get_calldata(selector_mint, (ALICE, mint_alice).abi_encode());

        let mint_result = run_tx(&mut db, &erc20, calldata_mint, &ALICE).unwrap();
        assert!(mint_result.status, "Mint transaction failed");

        // Mint tokens to Bob
        let mint_bob = U256::from(20e18);
        let calldata_mint = get_calldata(selector_mint, (BOB, mint_bob).abi_encode());

        let mint_result = run_tx(&mut db, &erc20, calldata_mint, &ALICE).unwrap();
        assert!(mint_result.status, "Mint transaction failed");

        // Approve Carol to spend 10 tokens from Alice
        let allowance_carol = U256::from(5e18);
        let selector_approve = get_selector_from_sig("approve(address,uint256)");
        let calldata_approve =
            get_calldata(selector_approve, (CAROL, allowance_carol).abi_encode());
        let approve_result = run_tx(&mut db, &erc20, calldata_approve, &ALICE).unwrap();
        assert!(approve_result.status, "Approve transaction failed");

        // EXPECTED STORAGE LAYOUT:
        //
        // pub struct ERC20 {
        //     total_supply: Slot<U256>,                                Slot: 0
        //     balances: Mapping<Address, U256>,                        Slot: keccak256(address, 1)
        //     allowances: Mapping<Address, Mapping<Address, U256>>,    Slot: keccak256(address, keccak256(address, 2))
        //     owner: Slot<Address>,                                    Slot: 3
        // }

        // Assert `total_supply` is set to track the correct slot
        let expected_slot = U256::from(0);
        assert_eq!(
            mint_alice + mint_bob,
            read_db_slot(&mut db, erc20, expected_slot)
        );

        let balances_id = U256::from(1);
        // Assert `balances[ALICE]` is set to track the correct slot
        let expected_slot = get_mapping_slot(ALICE.abi_encode(), balances_id);
        assert_eq!(mint_alice, read_db_slot(&mut db, erc20, expected_slot));

        // Assert `balances[BOB]` is set to track the correct slot
        let expected_slot = get_mapping_slot(BOB.abi_encode(), balances_id);
        assert_eq!(mint_bob, read_db_slot(&mut db, erc20, expected_slot));

        let allowances_id = U256::from(2);
        // Assert `allowance[ALICE][CAROL]` is set to track the correct slot
        let id = get_mapping_slot(ALICE.abi_encode(), allowances_id);
        let expected_slot = get_mapping_slot(CAROL.abi_encode(), id);
        assert_eq!(allowance_carol, read_db_slot(&mut db, erc20, expected_slot));

        // Assert `owner` is set to track the correct slot
        let expected_slot = U256::from(3);
        assert_eq!(
            read_db_slot(&mut db, erc20, expected_slot),
            ALICE.into_word().into(),
        );
    }

    #[test]
    fn test_custom_error() {
        let (mut db, erc20) = setup_erc20(ALICE);

        // Define fn selectors
        let selector_mint = get_selector_from_sig("mint(address,uint256)");
        let selector_approve = get_selector_from_sig("approve(address,uint256)");
        let selector_transfer = get_selector_from_sig("transfer(address,uint256)");
        let selector_transfer_from =
            get_selector_from_sig("transfer_from(address,address,uint256)");

        // Mint 42 tokens to Alice
        let value_mint = U256::from(42e18);
        let calldata_mint = get_calldata(selector_mint, (ALICE, value_mint).abi_encode());

        let mint_result = run_tx(&mut db, &erc20, calldata_mint.clone(), &ALICE).unwrap();
        assert!(mint_result.status, "Mint transaction failed");

        // Attempt mint with Bob (not contract owner)
        let only_owner_result =
            run_tx(&mut db, &erc20, calldata_mint, &BOB).expect_err("Mint transaction succeeded");
        assert!(
            only_owner_result.matches_custom_error("ERC20Error::OnlyOwner"),
            "Incorrect error"
        );

        // Attempt transfer 43 tokens (more than her balance) from Alice to Bob
        let value_transfer = U256::from(43e18);
        let calldata_transfer = get_calldata(selector_transfer, (BOB, value_transfer).abi_encode());

        assert!(value_transfer > value_mint);
        let insufficient_balance_result =
            run_tx(&mut db, &erc20, calldata_transfer.clone(), &ALICE)
                .expect_err("Transfer transaction succeeded");
        assert!(
            insufficient_balance_result.matches_custom_error_with_args(
                "ERC20Error::InsufficientBalance(uint256)",
                value_mint.abi_encode()
            ),
            "Incorrect error signature"
        );

        // Approve Carol to spend 10 tokens from Alice
        let value_approve = U256::from(10e18);
        let calldata_approve = get_calldata(selector_approve, (CAROL, value_approve).abi_encode());

        let approve_result = run_tx(&mut db, &erc20, calldata_approve.clone(), &ALICE).unwrap();
        assert!(approve_result.status, "Approve transaction failed");

        // Attempt transfer_from of all tokens (more than allowance) from Alice to Carol
        let calldata_transfer_from = get_calldata(
            selector_transfer_from,
            (ALICE, CAROL, value_mint).abi_encode(),
        );

        assert!(value_mint > value_approve);
        let insufficient_allowance_result =
            run_tx(&mut db, &erc20, calldata_transfer_from.clone(), &CAROL)
                .expect_err("Transfer From tx succeeded");
        assert!(
            insufficient_allowance_result.matches_custom_error_with_args(
                "ERC20Error::InsufficientAllowance(uint256)",
                value_approve.abi_encode()
            ),
            "Incorrect error signature"
        );
    }

    #[test]
    fn test_custom_error_with_cross_contract_call() {
        let (mut db, erc20) = setup_erc20(ALICE);
        let erc20x = setup_erc20x(&mut db);

        // Define fn selectors
        let selector_mint = get_selector_from_sig("mint(address,uint256)");
        let selector_x_mint = get_selector_from_sig("x_mint(address,uint256,address)");
        let selector_approve = get_selector_from_sig("approve(address,uint256)");
        let selector_balance_of = get_selector_from_sig("balance_of(address)");
        let selector_x_transfer_from =
            get_selector_from_sig("x_transfer_from(address,uint256,address)");

        // Mint 42 tokens to Alice
        let value_mint = U256::from(42e18);
        let calldata_mint = get_calldata(selector_mint, (ALICE, value_mint).abi_encode());

        let mint_result = run_tx(&mut db, &erc20, calldata_mint.clone(), &ALICE).unwrap();
        assert!(mint_result.status, "Mint transaction failed");

        // Attempt to cross-mint 100 tokens to Bob (erc20x is not the contract owner)
        let value_x_steal = U256::from(100e18);
        let calldata_x_mint =
            get_calldata(selector_x_mint, (BOB, value_x_steal, erc20).abi_encode());

        let only_owner_result = run_tx(&mut db, &erc20x, calldata_x_mint, &BOB)
            .expect_err("Mint transaction succeeded");
        assert!(
            only_owner_result.matches_custom_error("ERC20Error::OnlyOwner"),
            "Incorrect error"
        );

        // Attempt cross-transfer 100 tokens (without allowance) from Alice to Bob
        let calldata_x_transfer_from = get_calldata(
            selector_x_transfer_from,
            (ALICE, value_x_steal, erc20).abi_encode(),
        );

        let zero_amount_result = run_tx(&mut db, &erc20x, calldata_x_transfer_from.clone(), &BOB)
            .expect_err("Transfer transaction succeeded");
        assert!(
            zero_amount_result.matches_custom_error("ERC20Error::ZeroAmount"),
            "Incorrect error signature"
        );

        // Approve ERC20x to spend 10 tokens from Alice
        let value_approve = U256::from(10e18);
        let calldata_approve = get_calldata(selector_approve, (erc20x, value_approve).abi_encode());

        let approve_result = run_tx(&mut db, &erc20, calldata_approve.clone(), &ALICE).unwrap();
        assert!(approve_result.status, "Approve transaction failed");

        // Attempt cross-transfer 100 tokens (with a 10 token allowance) from Alice to Bob
        let fallback_x_transfer_result =
            run_tx(&mut db, &erc20x, calldata_x_transfer_from, &BOB).expect("Error executing tx");
        assert!(
            fallback_x_transfer_result.status,
            "Cross-transfer from transaction failed"
        );

        // Check Bob's balance
        let calldata_balance_of = get_calldata(selector_balance_of, BOB.abi_encode());

        let bob_balance_result = run_tx(&mut db, &erc20, calldata_balance_of.clone(), &BOB)
            .expect("Error executing tx")
            .output;

        assert_eq!(
            U256::from_be_bytes::<32>(bob_balance_result.as_slice().try_into().unwrap()),
            value_approve,
            "Incorrect balance"
        );
    }

    #[test]
    fn test_string_error() {
        let (mut db, erc20) = setup_erc20(ALICE);
        let erc20x = setup_erc20x(&mut db);

        // Define fn selectors
        let selector_panic = get_selector_from_sig("panics()");
        let selector_x_mint_panic = get_selector_from_sig("x_mint_panics(address,uint256,address)");

        // Attempt a call that panics with a string msg
        let panic_result = run_tx(
            &mut db,
            &erc20x,
            get_calldata(selector_panic, vec![]),
            &ALICE,
        )
        .expect_err("Tx succeeded");
        assert!(
            panic_result.matches_string_error("This function always panics"),
            "Incorrect error"
        );

        // Attempt a call that panics with a string msg
        let calldata_x_mint = get_calldata(
            selector_x_mint_panic,
            (ALICE, U256::from(1e18), erc20).abi_encode(),
        );

        let x_mint_panic_result =
            run_tx(&mut db, &erc20x, calldata_x_mint, &ALICE).expect_err("Tx succeeded");
        assert!(
            x_mint_panic_result.matches_string_error("ERC20::mint() failed!: OnlyOwner"),
            "Incorrect error"
        );
    }
}


================================================
File: r55/src/test_utils.rs
================================================
use alloy_core::hex::FromHex;
use alloy_primitives::address;
use revm::Database;
pub use revm::{
    primitives::{keccak256, ruint::Uint, AccountInfo, Address, Bytecode, Bytes, U256},
    InMemoryDB,
};
use std::{fs, path::Path, sync::Once};

static INIT: Once = Once::new();

pub const ALICE: Address = address!("000000000000000000000000000000000000000A");
pub const BOB: Address = address!("000000000000000000000000000000000000000B");
pub const CAROL: Address = address!("000000000000000000000000000000000000000C");

pub fn initialize_logger() {
    INIT.call_once(|| {
        let log_level = std::env::var("RUST_LOG").unwrap_or("INFO".to_owned());
        let tracing_sub = tracing_subscriber::fmt()
            .with_max_level(tracing::Level::DEBUG)
            .with_env_filter(tracing_subscriber::EnvFilter::new(log_level))
            .with_target(false)
            .finish();
        tracing::subscriber::set_global_default(tracing_sub)
            .expect("Setting tracing subscriber failed");
    });
}

pub fn add_balance_to_db(db: &mut InMemoryDB, addr: Address, value: u64) {
    db.insert_account_info(addr, AccountInfo::from_balance(U256::from(value)));
}

pub fn add_contract_to_db(db: &mut InMemoryDB, addr: Address, bytecode: Bytes) {
    let account = AccountInfo::new(
        Uint::from(0),
        0,
        keccak256(&bytecode),
        Bytecode::new_raw(bytecode),
    );
    db.insert_account_info(addr, account);
}

pub fn get_selector_from_sig(sig: &str) -> [u8; 4] {
    keccak256(sig)[0..4]
        .try_into()
        .expect("Selector should have exactly 4 bytes")
}

pub fn get_calldata(selector: [u8; 4], mut args: Vec<u8>) -> Vec<u8> {
    let mut calldata = selector.to_vec();
    calldata.append(&mut args);

    calldata
}

pub fn get_mapping_slot(key_bytes: Vec<u8>, id: U256) -> U256 {
    let mut data_bytes = Vec::with_capacity(64);
    data_bytes.extend_from_slice(&key_bytes);
    data_bytes.extend_from_slice(&id.to_be_bytes::<32>());

    keccak256(data_bytes).into()
}

pub fn read_db_slot(db: &mut InMemoryDB, contract: Address, slot: U256) -> U256 {
    db.storage(contract, slot)
        .expect("Unable to read storge slot")
}

pub fn load_bytecode_from_file<P: AsRef<Path>>(path: P) -> Bytes {
    let content = fs::read_to_string(path).expect("Unable to load bytecode from path");
    let trimmed = content.trim().trim_start_matches("0x");
    Bytes::from_hex(trimmed).expect("Unable to parse file content as bytes")
}


================================================
File: r55/src/generated/contract_bytecodes.rs
================================================
// Auto-generated bytecode module

pub fn get_contract_bytecode(name: &str) -> Option<(&'static [u8], &'static [u8])> {
    match name {
        _ => None,
    }
}


================================================
File: r55/tests/e2e.rs
================================================
use alloy_primitives::{address, Address, Bytes, U256};
use alloy_sol_types::SolValue;
use r55::{
    compile_deploy, compile_with_prefix,
    exec::{deploy_contract, run_tx},
    test_utils::{add_balance_to_db, get_selector_from_sig, initialize_logger},
};
use revm::InMemoryDB;
use tracing::{debug, error, info};

const ERC20_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../examples/erc20");
const ERC20X_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../examples/erc20x");

#[test]
fn erc20() {
    initialize_logger();

    let mut db = InMemoryDB::default();

    let alice: Address = address!("000000000000000000000000000000000000000A");
    add_balance_to_db(&mut db, alice, 1e18 as u64);

    let constructor = alice.abi_encode();
    let bytecode = compile_with_prefix(compile_deploy, ERC20_PATH).unwrap();
    let erc20 = deploy_contract(&mut db, bytecode, Some(constructor)).unwrap();

    let total_supply = get_selector_from_sig("total_supply()");
    let selector_balance = get_selector_from_sig("balance_of(address)");
    let selector_mint = get_selector_from_sig("mint(address,uint256)");

    info!("----------------------------------------------------------");
    info!("-- MINT TX -----------------------------------------------");
    info!("----------------------------------------------------------");
    let value_mint = U256::from(42e18);
    let mut calldata_mint = (alice, value_mint).abi_encode();
    let mut complete_calldata_mint = selector_mint.to_vec();
    complete_calldata_mint.append(&mut calldata_mint);

    debug!(
        "Tx Calldata:\n> {:#?}",
        Bytes::from(complete_calldata_mint.clone())
    );
    match run_tx(&mut db, &erc20, complete_calldata_mint.clone(), &alice) {
        Ok(res) => info!("{}", res),
        Err(e) => {
            error!("Error when executing tx! {}", e);
            panic!()
        }
    };

    info!("----------------------------------------------------------");
    info!("-- TOTAL SUPPLY ------------------------------------------");
    info!("----------------------------------------------------------");
    debug!("Tx Calldata:\n> {:#?}", Bytes::from(total_supply.to_vec()));
    match run_tx(&mut db, &erc20, total_supply.to_vec(), &alice) {
        Ok(res) => info!("Success! {}", res),
        Err(e) => {
            error!("Error when executing tx! {}", e);
            panic!()
        }
    };

    info!("----------------------------------------------------------");
    info!("-- BALANCE OF TX -----------------------------------------");
    info!("----------------------------------------------------------");
    let mut calldata_balance = alice.abi_encode();
    let mut complete_calldata_balance = selector_balance.to_vec();
    complete_calldata_balance.append(&mut calldata_balance);

    debug!(
        "Tx Calldata:\n> {:#?}",
        Bytes::from(complete_calldata_balance.clone())
    );
    match run_tx(&mut db, &erc20, complete_calldata_balance.clone(), &alice) {
        Ok(res) => info!("{}", res),
        Err(e) => {
            error!("Error when executing tx! {}", e);
            panic!()
        }
    };
}

#[test]
fn erc20x() {
    initialize_logger();

    let mut db = InMemoryDB::default();

    let alice: Address = address!("000000000000000000000000000000000000000A");
    add_balance_to_db(&mut db, alice, 1e18 as u64);

    let bytecode_x = compile_with_prefix(compile_deploy, ERC20X_PATH).unwrap();
    let erc20x = deploy_contract(&mut db, bytecode_x, None).unwrap();

    let constructor = erc20x.abi_encode();
    let bytecode = compile_with_prefix(compile_deploy, ERC20_PATH).unwrap();
    let erc20 = deploy_contract(&mut db, bytecode, Some(constructor)).unwrap();

    let total_supply = get_selector_from_sig("total_supply()");
    let selector_x_balance = get_selector_from_sig("x_balance_of(address,address)");
    let selector_x_mint = get_selector_from_sig("x_mint(address,uint256,address)");

    info!("----------------------------------------------------------");
    info!("-- X-MINT TX -----------------------------------------------");
    info!("----------------------------------------------------------");
    let value_x_mint = U256::from(42e18);
    let mut complete_calldata_x_mint = selector_x_mint.to_vec();
    complete_calldata_x_mint.append(&mut (alice, value_x_mint, erc20).abi_encode());

    debug!(
        "Tx Calldata:\n> {:#?}",
        Bytes::from(complete_calldata_x_mint.clone())
    );
    match run_tx(&mut db, &erc20x, complete_calldata_x_mint.clone(), &alice) {
        Ok(res) => info!("{}", res),
        Err(e) => {
            error!("Error when executing tx! {:#?}", e);
            panic!()
        }
    };

    info!("----------------------------------------------------------");
    info!("-- TOTAL SUPPLY ------------------------------------------");
    info!("----------------------------------------------------------");
    debug!("Tx Calldata:\n> {:#?}", Bytes::from(total_supply.to_vec()));
    match run_tx(&mut db, &erc20, total_supply.to_vec(), &alice) {
        Ok(res) => info!("Success! {}", res),
        Err(e) => {
            error!("Error when executing tx! {:#?}", e);
            panic!()
        }
    };

    info!("----------------------------------------------------------");
    info!("-- X-CONTRACT BALANCE OF TX ------------------------------");
    info!("----------------------------------------------------------");
    let mut calldata_x_balance = (alice, erc20).abi_encode();
    let mut complete_calldata_x_balance = selector_x_balance.to_vec();
    complete_calldata_x_balance.append(&mut calldata_x_balance);

    debug!(
        "Tx calldata:\n> {:#?}",
        Bytes::from(complete_calldata_x_balance.clone())
    );
    match run_tx(
        &mut db,
        &erc20x,
        complete_calldata_x_balance.clone(),
        &alice,
    ) {
        Ok(res) => info!("{}", res),
        Err(e) => {
            error!("Error when executing tx! {}", e);
            panic!();
        }
    }
}


================================================
File: r55/tests/erc20.rs
================================================
use alloy_primitives::{Address, B256, U256};
use alloy_sol_types::SolValue;
use r55::{
    compile_deploy, compile_with_prefix,
    exec::{deploy_contract, run_tx},
    test_utils::{
        add_balance_to_db, get_calldata, get_selector_from_sig, initialize_logger, ALICE, BOB,
        CAROL,
    },
};
use revm::InMemoryDB;

const ERC20_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../examples/erc20");

struct ERC20Setup {
    db: InMemoryDB,
    token: Address,
    owner: Address,
}

fn erc20_setup(owner: Address) -> ERC20Setup {
    initialize_logger();
    let mut db = InMemoryDB::default();

    // Fund user accounts with some ETH
    for user in [ALICE, BOB, CAROL] {
        add_balance_to_db(&mut db, user, 1e18 as u64);
    }

    // Deploy contract
    let constructor = owner.abi_encode();
    let bytecode = compile_with_prefix(compile_deploy, ERC20_PATH).unwrap();
    let token = deploy_contract(&mut db, bytecode, Some(constructor)).unwrap();

    ERC20Setup { db, token, owner }
}

#[test]
fn test_erc20_deployment() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);

    let selector_owner = get_selector_from_sig("owner()");
    let owner_result = run_tx(&mut db, &token, selector_owner.to_vec(), &ALICE)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        Address::from_word(B256::from_slice(owner_result.as_slice())),
        owner,
        "Incorrect owner"
    );
}

#[test]
fn test_erc20_mint() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);
    let recipient = BOB;

    let mint_amount = U256::from(100e18);
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (recipient, mint_amount).abi_encode());

    let mint_result = run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing tx");
    assert!(mint_result.status, "Mint transaction failed");

    // Verify balance
    let selector_balance = get_selector_from_sig("balance_of(address)");
    let calldata_balance = get_calldata(selector_balance, recipient.abi_encode());

    let balance_result = run_tx(&mut db, &token, calldata_balance, &owner)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        U256::from_be_bytes::<32>(balance_result.as_slice().try_into().unwrap()),
        mint_amount,
        "Incorrect balance"
    );
}

#[test]
fn test_erc20_transfer() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);
    let recipient = BOB;

    // Mint initial tokens to owner
    let mint_amount = U256::from(100e18);
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (owner, mint_amount).abi_encode());

    let mint_result = run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing tx");
    assert!(mint_result.status, "Mint transaction failed");

    // Transfer
    let transfer_amount = U256::from(50e18);
    let selector_transfer = get_selector_from_sig("transfer(address,uint256)");
    let calldata_transfer =
        get_calldata(selector_transfer, (recipient, transfer_amount).abi_encode());

    let transfer_result =
        run_tx(&mut db, &token, calldata_transfer, &owner).expect("Error executing tx");
    assert!(transfer_result.status, "Transfer transaction failed");

    // Verify balances
    let selector_balance = get_selector_from_sig("balance_of(address)");

    // Check recipient balance
    let calldata_recipient_balance = get_calldata(selector_balance, recipient.abi_encode());

    let recipient_balance_result = run_tx(&mut db, &token, calldata_recipient_balance, &owner)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        U256::from_be_bytes::<32>(recipient_balance_result.as_slice().try_into().unwrap()),
        transfer_amount,
        "Incorrect recipient balance"
    );

    // Check owner remaining balance
    let calldata_owner_balance = get_calldata(selector_balance, owner.abi_encode());

    let owner_balance_result = run_tx(&mut db, &token, calldata_owner_balance, &owner)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        U256::from_be_bytes::<32>(owner_balance_result.as_slice().try_into().unwrap()),
        mint_amount - transfer_amount,
        "Incorrect owner balance"
    );
}

#[test]
fn test_erc20_approve_and_transfer_from() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);
    let spender = BOB;
    let recipient = CAROL;

    // Mint initial tokens to owner
    let mint_amount = U256::from(100e18);
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (owner, mint_amount).abi_encode());

    let mint_result = run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing tx");
    assert!(mint_result.status, "Mint transaction failed");

    // Approve
    let approve_amount = U256::from(50e18);
    let selector_approve = get_selector_from_sig("approve(address,uint256)");
    let calldata_approve = get_calldata(selector_approve, (spender, approve_amount).abi_encode());

    let approve_result =
        run_tx(&mut db, &token, calldata_approve, &owner).expect("Error executing tx");
    assert!(approve_result.status, "Approve transaction failed");

    // Transfer from owner
    let transfer_amount = U256::from(30e18);
    let selector_transfer_from = get_selector_from_sig("transfer_from(address,address,uint256)");
    let calldata_transfer_from = get_calldata(
        selector_transfer_from,
        (owner, recipient, transfer_amount).abi_encode(),
    );

    let transfer_from_result =
        run_tx(&mut db, &token, calldata_transfer_from, &spender).expect("Error executing tx");
    assert!(
        transfer_from_result.status,
        "TransferFrom transaction failed"
    );

    // Verify balances and allowance
    let selector_balance = get_selector_from_sig("balance_of(address)");
    let selector_allowance = get_selector_from_sig("allowance(address,address)");

    // Check recipient balance
    let calldata_recipient_balance = get_calldata(selector_balance, recipient.abi_encode());

    let recipient_balance_result = run_tx(&mut db, &token, calldata_recipient_balance, &owner)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        U256::from_be_bytes::<32>(recipient_balance_result.as_slice().try_into().unwrap()),
        transfer_amount,
        "Incorrect recipient balance"
    );

    // Check remaining allowance
    let calldata_allowance = get_calldata(selector_allowance, (owner, spender).abi_encode());

    let allowance_result = run_tx(&mut db, &token, calldata_allowance, &owner)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        U256::from_be_bytes::<32>(allowance_result.as_slice().try_into().unwrap()),
        approve_amount - transfer_amount,
        "Incorrect allowance"
    );
}

#[test]
fn test_erc20_transfer_insufficient_balance() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);
    let recipient = BOB;

    // Mint tokens to owner
    let mint_amount = U256::from(1e18);
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (owner, mint_amount).abi_encode());

    run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing mint tx");

    // Attempt to transfer more tokens than balance
    let transfer_amount = U256::from(5e18);
    let selector_transfer = get_selector_from_sig("transfer(address,uint256)");
    let calldata_transfer =
        get_calldata(selector_transfer, (recipient, transfer_amount).abi_encode());

    let result = run_tx(&mut db, &token, calldata_transfer, &owner)
        .expect_err("Transfer transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error_with_args(
            "ERC20Error::InsufficientBalance(uint256)",
            mint_amount.abi_encode()
        ),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc20_transfer_from_insufficient_allowance() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);
    let spender = BOB;
    let recipient = CAROL;

    // Mint tokens to owner
    let mint_amount = U256::from(1e18);
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (owner, mint_amount).abi_encode());

    run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing mint tx");

    // Approve some tokens
    let approve_amount = U256::from(1e18);
    let selector_approve = get_selector_from_sig("approve(address,uint256)");
    let calldata_approve = get_calldata(selector_approve, (spender, approve_amount).abi_encode());

    run_tx(&mut db, &token, calldata_approve, &owner).expect("Error executing approve tx");

    // Attempt to transfer more than allowance
    let transfer_amount = U256::from(5e18);
    let selector_transfer_from = get_selector_from_sig("transfer_from(address,address,uint256)");
    let calldata_transfer_from = get_calldata(
        selector_transfer_from,
        (owner, recipient, transfer_amount).abi_encode(),
    );

    let result = run_tx(&mut db, &token, calldata_transfer_from, &spender)
        .expect_err("TransferFrom transaction succeeded when it should fail");

    assert!(transfer_amount > approve_amount);
    assert!(
        result.matches_custom_error_with_args(
            "ERC20Error::InsufficientAllowance(uint256)",
            approve_amount.abi_encode()
        ),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc20_transfer_from_insufficient_balance() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);
    let spender = BOB;
    let recipient = CAROL;

    // Mint tokens to owner
    let mint_amount = U256::from(1e18);
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (owner, mint_amount).abi_encode());

    run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing mint tx");

    // Approve transfer amount
    let transfer_amount = U256::from(2e18);
    let selector_approve = get_selector_from_sig("approve(address,uint256)");
    let calldata_approve = get_calldata(selector_approve, (spender, transfer_amount).abi_encode());

    run_tx(&mut db, &token, calldata_approve, &owner).expect("Error executing approve tx");

    // Attempt to transfer more than balance
    let selector_transfer_from = get_selector_from_sig("transfer_from(address,address,uint256)");
    let calldata_transfer_from = get_calldata(
        selector_transfer_from,
        (owner, recipient, transfer_amount).abi_encode(),
    );

    let result = run_tx(&mut db, &token, calldata_transfer_from, &spender)
        .expect_err("TransferFrom transaction succeeded when it should fail");

    assert!(transfer_amount > mint_amount);
    assert!(
        result.matches_custom_error_with_args(
            "ERC20Error::InsufficientBalance(uint256)",
            mint_amount.abi_encode()
        ),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc20_mint_unauthorized() {
    let ERC20Setup {
        mut db,
        token,
        owner: _,
    } = erc20_setup(ALICE);
    let unauthorized = BOB;
    let recipient = CAROL;

    let mint_amount = U256::from(1e18);
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (recipient, mint_amount).abi_encode());

    let result = run_tx(&mut db, &token, calldata_mint, &unauthorized)
        .expect_err("Mint transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC20Error::OnlyOwner"),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc20_zero_address_checks() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);
    let zero_address = Address::ZERO;

    // Test mint to zero address
    let mint_amount = U256::from(1e18);
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (zero_address, mint_amount).abi_encode());

    let result = run_tx(&mut db, &token, calldata_mint, &owner)
        .expect_err("Mint transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC20Error::ZeroAddress"),
        "Incorrect error signature"
    );

    // Test transfer to zero address
    let selector_transfer = get_selector_from_sig("transfer(address,uint256)");
    let calldata_transfer =
        get_calldata(selector_transfer, (zero_address, mint_amount).abi_encode());

    let result = run_tx(&mut db, &token, calldata_transfer, &owner)
        .expect_err("Transfer transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC20Error::ZeroAddress"),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc20_zero_amount_checks() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);
    let recipient = BOB;

    // Test mint zero amount
    let zero_amount = U256::ZERO;
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (recipient, zero_amount).abi_encode());

    let result = run_tx(&mut db, &token, calldata_mint, &owner)
        .expect_err("Mint transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC20Error::ZeroAmount"),
        "Incorrect error signature"
    );

    // Test transfer zero amount
    let selector_transfer = get_selector_from_sig("transfer(address,uint256)");
    let calldata_transfer = get_calldata(selector_transfer, (recipient, zero_amount).abi_encode());

    let result = run_tx(&mut db, &token, calldata_transfer, &owner)
        .expect_err("Transfer transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC20Error::ZeroAmount"),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc20_self_approval() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);

    // Attempt to approve self
    let approve_amount = U256::from(1e18);
    let selector_approve = get_selector_from_sig("approve(address,uint256)");
    let calldata_approve = get_calldata(selector_approve, (owner, approve_amount).abi_encode());

    let result = run_tx(&mut db, &token, calldata_approve, &owner)
        .expect_err("Approve transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC20Error::SelfApproval"),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc20_self_transfer() {
    let ERC20Setup {
        mut db,
        token,
        owner,
    } = erc20_setup(ALICE);

    // First mint some tokens
    let mint_amount = U256::from(1e18);
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (owner, mint_amount).abi_encode());

    run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing mint tx");

    // Attempt direct self-transfer
    let selector_transfer = get_selector_from_sig("transfer(address,uint256)");
    let calldata_transfer = get_calldata(selector_transfer, (owner, mint_amount).abi_encode());

    let result = run_tx(&mut db, &token, calldata_transfer, &owner)
        .expect_err("Transfer transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC20Error::SelfTransfer"),
        "Incorrect error signature"
    );

    // Attempt self-transfer through transferFrom
    let spender = BOB;

    // First approve spender
    let selector_approve = get_selector_from_sig("approve(address,uint256)");
    let calldata_approve = get_calldata(selector_approve, (spender, mint_amount).abi_encode());

    run_tx(&mut db, &token, calldata_approve, &owner).expect("Error executing approve tx");

    // Attempt transferFrom to same address
    let selector_transfer_from = get_selector_from_sig("transfer_from(address,address,uint256)");
    let calldata_transfer_from = get_calldata(
        selector_transfer_from,
        (owner, owner, mint_amount).abi_encode(),
    );

    let result = run_tx(&mut db, &token, calldata_transfer_from, &spender)
        .expect_err("TransferFrom transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC20Error::SelfTransfer"),
        "Incorrect error signature"
    );
}


================================================
File: r55/tests/erc721.rs
================================================
use alloy_primitives::{Address, B256, U256};
use alloy_sol_types::SolValue;
use r55::{
    compile_deploy, compile_with_prefix,
    exec::{deploy_contract, run_tx},
    test_utils::{
        add_balance_to_db, get_calldata, get_selector_from_sig, initialize_logger, ALICE, BOB,
        CAROL,
    },
};
use revm::InMemoryDB;

const ERC721_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../examples/erc721");

struct ERC721Setup {
    db: InMemoryDB,
    token: Address,
    owner: Address,
}

fn erc721_setup(owner: Address) -> ERC721Setup {
    initialize_logger();
    let mut db = InMemoryDB::default();

    // Fund user accounts with some ETH
    for user in [ALICE, BOB, CAROL] {
        add_balance_to_db(&mut db, user, 1e18 as u64);
    }

    // Deploy contract
    let constructor = owner.abi_encode();
    let bytecode = compile_with_prefix(compile_deploy, ERC721_PATH).unwrap();
    let token = deploy_contract(&mut db, bytecode, Some(constructor)).unwrap();

    ERC721Setup { db, token, owner }
}

#[test]
fn test_erc721_deployment() {
    let ERC721Setup {
        mut db,
        token,
        owner,
    } = erc721_setup(ALICE);

    let selector_owner = get_selector_from_sig("owner()");
    let owner_result = run_tx(&mut db, &token, selector_owner.to_vec(), &ALICE)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        Address::from_word(B256::from_slice(owner_result.as_slice())),
        owner,
        "Incorrect owner"
    );
}

#[test]
fn test_erc721_mint() {
    let ERC721Setup {
        mut db,
        token,
        owner,
    } = erc721_setup(ALICE);
    let recipient = BOB;
    let token_id = U256::from(1);

    // Mint token
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (recipient, token_id).abi_encode());

    let mint_result = run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing tx");
    assert!(mint_result.status, "Mint transaction failed");

    // Verify ownership
    let selector_owner_of = get_selector_from_sig("owner_of(uint256)");
    let calldata_owner = get_calldata(selector_owner_of, token_id.abi_encode());

    let owner_result = run_tx(&mut db, &token, calldata_owner, &owner)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        Address::from_word(B256::from_slice(owner_result.as_slice())),
        recipient,
        "Incorrect token owner"
    );

    // Verify balance
    let selector_balance = get_selector_from_sig("balance_of(address)");
    let calldata_balance = get_calldata(selector_balance, recipient.abi_encode());

    let balance_result = run_tx(&mut db, &token, calldata_balance, &owner)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        U256::from_be_bytes::<32>(balance_result.as_slice().try_into().unwrap()),
        U256::from(1),
        "Incorrect balance"
    );
}

#[test]
fn test_erc721_approve_and_transfer_from() {
    let ERC721Setup {
        mut db,
        token,
        owner,
    } = erc721_setup(ALICE);
    let token_owner = BOB;
    let spender = CAROL;
    let recipient = ALICE;
    let token_id = U256::from(1);

    // Mint token to initial owner
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (token_owner, token_id).abi_encode());

    run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing mint tx");

    // Approve spender
    let selector_approve = get_selector_from_sig("approve(address,uint256)");
    let calldata_approve = get_calldata(selector_approve, (spender, token_id).abi_encode());

    let approve_result =
        run_tx(&mut db, &token, calldata_approve, &token_owner).expect("Error executing tx");
    assert!(approve_result.status, "Approve transaction failed");

    // Transfer from token_owner to recipient
    let selector_transfer_from = get_selector_from_sig("transfer_from(address,address,uint256)");
    let calldata_transfer_from = get_calldata(
        selector_transfer_from,
        (token_owner, recipient, token_id).abi_encode(),
    );

    let transfer_result =
        run_tx(&mut db, &token, calldata_transfer_from, &spender).expect("Error executing tx");
    assert!(transfer_result.status, "TransferFrom transaction failed");

    // Verify new owner
    let selector_owner_of = get_selector_from_sig("owner_of(uint256)");
    let calldata_owner = get_calldata(selector_owner_of, token_id.abi_encode());

    let owner_result = run_tx(&mut db, &token, calldata_owner, &owner)
        .expect("Error executing tx")
        .output;

    assert_eq!(
        Address::from_word(B256::from_slice(owner_result.as_slice())),
        recipient,
        "Incorrect token owner after transfer"
    );
}

#[test]
fn test_erc721_set_approval_for_all() {
    let ERC721Setup {
        mut db,
        token,
        owner,
    } = erc721_setup(ALICE);
    let token_owner = BOB;
    let operator = CAROL;
    let token_id = U256::from(1);

    // Mint token
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (token_owner, token_id).abi_encode());

    run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing mint tx");

    // Set approval for all
    let selector_set_approval = get_selector_from_sig("set_approval_for_all(address,bool)");
    let calldata_set_approval = get_calldata(selector_set_approval, (operator, true).abi_encode());

    let approval_result =
        run_tx(&mut db, &token, calldata_set_approval, &token_owner).expect("Error executing tx");
    assert!(
        approval_result.status,
        "SetApprovalForAll transaction failed"
    );

    // Verify approval status
    let selector_is_approved = get_selector_from_sig("is_approved_for_all(address,address)");
    let calldata_is_approved =
        get_calldata(selector_is_approved, (token_owner, operator).abi_encode());

    let is_approved_result = run_tx(&mut db, &token, calldata_is_approved, &owner)
        .expect("Error executing tx")
        .output;

    assert_eq!(is_approved_result[31], 1, "Incorrect approval status");
}

#[test]
fn test_erc721_mint_already_exists() {
    let ERC721Setup {
        mut db,
        token,
        owner,
    } = erc721_setup(ALICE);
    let recipient = BOB;
    let token_id = U256::from(1);

    // Mint token
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (recipient, token_id).abi_encode());

    run_tx(&mut db, &token, calldata_mint.clone(), &owner).expect("Error executing first mint tx");

    // Attempt second mint of same token ID
    let result = run_tx(&mut db, &token, calldata_mint, &owner)
        .expect_err("Mint transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC721Error::AlreadyMinted"),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc721_unauthorized_transfer() {
    let ERC721Setup {
        mut db,
        token,
        owner,
    } = erc721_setup(ALICE);
    let token_owner = BOB;
    let unauthorized = CAROL;
    let recipient = ALICE;
    let token_id = U256::from(1);

    // Mint token
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (token_owner, token_id).abi_encode());

    run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing mint tx");

    // Attempt unauthorized transfer
    let selector_transfer_from = get_selector_from_sig("transfer_from(address,address,uint256)");
    let calldata_transfer_from = get_calldata(
        selector_transfer_from,
        (token_owner, recipient, token_id).abi_encode(),
    );

    let result = run_tx(&mut db, &token, calldata_transfer_from, &unauthorized)
        .expect_err("Transfer transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC721Error::Unauthorized"),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc721_wrong_from_address() {
    let ERC721Setup {
        mut db,
        token,
        owner,
    } = erc721_setup(ALICE);
    let token_owner = BOB;
    let wrong_from = CAROL;
    let recipient = ALICE;
    let token_id = U256::from(1);

    // Mint token
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (token_owner, token_id).abi_encode());

    run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing mint tx");

    // Attempt transfer with wrong from address
    let selector_transfer_from = get_selector_from_sig("transfer_from(address,address,uint256)");
    let calldata_transfer_from = get_calldata(
        selector_transfer_from,
        (wrong_from, recipient, token_id).abi_encode(),
    );

    let result = run_tx(&mut db, &token, calldata_transfer_from, &token_owner)
        .expect_err("Transfer transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC721Error::WrongFrom"),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc721_zero_address_checks() {
    let ERC721Setup {
        mut db,
        token,
        owner,
    } = erc721_setup(ALICE);
    let zero_address = Address::ZERO;
    let token_id = U256::from(1);

    // Test mint to zero address
    let selector_mint = get_selector_from_sig("mint(address,uint256)");
    let calldata_mint = get_calldata(selector_mint, (zero_address, token_id).abi_encode());

    let result = run_tx(&mut db, &token, calldata_mint, &owner)
        .expect_err("Mint transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC721Error::ZeroAddress"),
        "Incorrect error signature"
    );

    // Test transfer to zero address
    let token_owner = BOB;

    // First mint token normally
    let calldata_mint = get_calldata(selector_mint, (token_owner, token_id).abi_encode());
    run_tx(&mut db, &token, calldata_mint, &owner).expect("Error executing mint tx");

    // Attempt transfer to zero address
    let selector_transfer_from = get_selector_from_sig("transfer_from(address,address,uint256)");
    let calldata_transfer_from = get_calldata(
        selector_transfer_from,
        (token_owner, zero_address, token_id).abi_encode(),
    );

    let result = run_tx(&mut db, &token, calldata_transfer_from, &token_owner)
        .expect_err("Transfer transaction succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC721Error::ZeroAddress"),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc721_balance_of_zero_address() {
    let ERC721Setup {
        mut db,
        token,
        owner: _,
    } = erc721_setup(ALICE);
    let zero_address = Address::ZERO;

    let selector_balance = get_selector_from_sig("balance_of(address)");
    let calldata_balance = get_calldata(selector_balance, zero_address.abi_encode());

    let result = run_tx(&mut db, &token, calldata_balance, &ALICE)
        .expect_err("Balance query succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC721Error::ZeroAddress"),
        "Incorrect error signature"
    );
}

#[test]
fn test_erc721_query_non_existent_token() {
    let ERC721Setup {
        mut db,
        token,
        owner: _,
    } = erc721_setup(ALICE);
    let non_existent_token_id = U256::from(999);

    let selector_owner_of = get_selector_from_sig("owner_of(uint256)");
    let calldata_owner = get_calldata(selector_owner_of, non_existent_token_id.abi_encode());

    let result = run_tx(&mut db, &token, calldata_owner, &ALICE)
        .expect_err("Owner query succeeded when it should fail");

    assert!(
        result.matches_custom_error("ERC721Error::NotMinted"),
        "Incorrect error signature"
    );
}


================================================
File: r55/tests/evm-contract-call.rs
================================================
use alloy_primitives::{Bytes, U256};
use alloy_sol_types::SolValue;
use r55::{
    compile_deploy, compile_with_prefix,
    exec::{deploy_contract, run_tx},
    test_utils::{
        add_balance_to_db, get_selector_from_sig, initialize_logger, load_bytecode_from_file,
    },
};
use revm::{
    primitives::{address, Address},
    InMemoryDB,
};
use tracing::{debug, error, info};

const EVM_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/tests/simple-evm-contract.txt");
const RISCV_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../examples/evm-caller");

// ------------------------------------------------------------------------------------------------
//    SIMPLE EVM CONTRACT
// ------------------------------------------------------------------------------------------------
//    SPDX-License-Identifier: UNLICENSED
//    pragma solidity ^0.8.13;
//
//    struct callParams { address target; bytes data; }
//
//    contract SimpleStorage {
//        uint256 number;
//
//        function set(uint256 num) public { number = num; }
//        function get() public view returns (uint256) { return number; }
//        function rawCall(callParams calldata params) public returns (bool success) {
//            (success, ) = params.target.call(params.data);
//        }
//    }
// ------------------------------------------------------------------------------------------------

#[test]
fn evm_call() {
    initialize_logger();

    let mut db = InMemoryDB::default();

    let bytecode_evm = load_bytecode_from_file(EVM_PATH);
    let bytecode_r55 = compile_with_prefix(compile_deploy, RISCV_PATH).unwrap();
    let evm = deploy_contract(&mut db, bytecode_evm, None).unwrap();
    let r55 = deploy_contract(&mut db, bytecode_r55, None).unwrap();

    let selector_get = get_selector_from_sig("get()");
    let selector_set = get_selector_from_sig("set(uint256)");
    let selector_raw_call = get_selector_from_sig("rawCall((address,bytes))");
    let selector_x_get = get_selector_from_sig("x_get(address)");
    let selector_x_set = get_selector_from_sig("x_set(address,uint256)");

    let alice: Address = address!("000000000000000000000000000000000000000A");
    add_balance_to_db(&mut db, alice, 1e18 as u64);

    info!("----------------------------------------------------------");
    info!("-- SET VALUE TX (EVM CONTRACT) ---------------------------");
    info!("----------------------------------------------------------");
    let value_set = U256::from(1e18);
    let mut calldata_set = value_set.abi_encode();
    let mut complete_calldata_set = selector_set.to_vec();
    complete_calldata_set.append(&mut calldata_set);

    debug!(
        "Tx Calldata:\n> {:#?}",
        Bytes::from(complete_calldata_set.clone())
    );
    match run_tx(&mut db, &evm, complete_calldata_set.clone(), &alice) {
        Ok(res) => info!("{}", res),
        Err(e) => {
            error!("Error when executing tx! {:#?}", e);
            panic!()
        }
    };

    info!("----------------------------------------------------------");
    info!("-- X-GET VALUE TX (R55 CONTRACT -> EVM CONTRACT) ----------");
    info!("----------------------------------------------------------");
    // call traces: r55.x_get() -> evm.get()
    let mut calldata_x_get = evm.abi_encode();
    let mut complete_calldata_x_get = selector_x_get.to_vec();
    complete_calldata_x_get.append(&mut calldata_x_get);

    debug!(
        "Tx calldata:\n> {:#?}",
        Bytes::from(complete_calldata_x_get.clone())
    );
    match run_tx(&mut db, &r55, complete_calldata_x_get.clone(), &alice) {
        Ok(res) => {
            assert_eq!(
                U256::from_be_bytes::<32>(res.output.as_slice().try_into().unwrap()),
                value_set
            );
            info!("{}", res)
        }
        Err(e) => {
            error!("Error when executing tx! {:#?}", e);
            panic!();
        }
    }

    info!("----------------------------------------------------------");
    info!("-- X-SET VALUE TX (R55 CONTRACT -> EVM CONTRACT) ----------");
    info!("----------------------------------------------------------");
    // call traces: r55.x_set() -> evm.set()
    let value_x_set = U256::from(3e18);
    let mut calldata_x_set = (evm, value_x_set).abi_encode();
    let mut complete_calldata_x_set = selector_x_set.to_vec();
    complete_calldata_x_set.append(&mut calldata_x_set);

    debug!(
        "Tx calldata:\n> {:#?}",
        Bytes::from(complete_calldata_x_set.clone())
    );
    match run_tx(&mut db, &r55, complete_calldata_x_set.clone(), &alice) {
        Ok(res) => info!("{}", res),
        Err(e) => {
            error!("Error when executing tx! {:#?}", e);
            panic!();
        }
    }

    info!("----------------------------------------------------------");
    info!("-- GET VALUE TX (EVM CONTRACT) ---------------------------");
    info!("----------------------------------------------------------");
    debug!("Tx Calldata:\n> {:#?}", Bytes::from(selector_get.to_vec()));
    match run_tx(&mut db, &evm, selector_get.to_vec(), &alice) {
        Ok(res) => {
            assert_eq!(
                U256::from_be_bytes::<32>(res.output.as_slice().try_into().unwrap()),
                value_x_set
            );
            info!("{}", res)
        }
        Err(e) => {
            error!("Error when executing tx! {:#?}", e);
            panic!()
        }
    };

    info!("----------------------------------------------------------");
    info!("-- RAW-CALL TX (EVM -> R55 -> EVM ) ----------------------");
    info!("----------------------------------------------------------");
    // call traces: evm.rawCall() -> r55.x_set() -> evm.set()
    let value_raw_call_x_set = U256::from(5e18);
    let mut calldata_x_set = (evm, value_raw_call_x_set).abi_encode();
    let mut complete_calldata_x_set = selector_x_set.to_vec();
    complete_calldata_x_set.append(&mut calldata_x_set);
    debug!(
        "Tx sub-calldata:\n> {:#?}",
        Bytes::from(complete_calldata_x_set.clone())
    );

    let mut calldata_raw_call = (r55, Bytes::from(complete_calldata_x_set)).abi_encode();
    let mut complete_calldata_raw_call = selector_raw_call.to_vec();
    complete_calldata_raw_call.append(&mut calldata_raw_call);
    debug!(
        "Tx calldata:\n> {:#?}",
        Bytes::from(complete_calldata_raw_call.clone())
    );
    match run_tx(&mut db, &evm, complete_calldata_raw_call.clone(), &alice) {
        Ok(res) => {
            assert_eq!(
                U256::from_be_bytes::<32>(res.output.as_slice()[..32].try_into().unwrap()),
                U256::from(1)
            );
            info!("{}", res)
        }
        Err(e) => {
            error!("Error when executing tx! {:#?}", e);
            panic!();
        }
    }

    info!("----------------------------------------------------------");
    info!("-- GET VALUE TX (EVM CONTRACT) ---------------------------");
    info!("----------------------------------------------------------");
    debug!("Tx Calldata:\n> {:#?}", Bytes::from(selector_get.to_vec()));
    match run_tx(&mut db, &evm, selector_get.to_vec(), &alice) {
        Ok(res) => {
            assert_eq!(
                U256::from_be_bytes::<32>(res.output.as_slice().try_into().unwrap()),
                value_raw_call_x_set
            );
            info!("{}", res)
        }
        Err(e) => {
            error!("Error when executing tx! {:#?}", e);
            panic!()
        }
    };
}


